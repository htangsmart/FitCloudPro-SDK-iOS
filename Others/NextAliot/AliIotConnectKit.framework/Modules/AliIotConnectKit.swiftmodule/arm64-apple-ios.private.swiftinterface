// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name AliIotConnectKit
@_exported import AliIotConnectKit
import AliIotConnectKit_Private
import CommonCrypto
import CoreBluetooth
import Darwin
import Dispatch
import Dispatch/*.DispatchTimeInterval*/
import Foundation
import Foundation/*.BlockOperation*/
import Foundation/*.Date*/
import Foundation/*.DateFormatter*/
import Foundation/*.NSCopying*/
import Foundation/*.NSLock*/
import Foundation/*.NSObject*/
import Foundation/*.NSRecursiveLock*/
import Foundation/*.Operation*/
import Foundation/*.OperationQueue*/
import Foundation/*.Thread*/
import Foundation/*.TimeInterval*/
import AliIotConnectKit_Private.OC
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct HistoricalSchedulerTimeConverter : AliIotConnectKit.VirtualTimeConverterType {
  public typealias VirtualTimeUnit = AliIotConnectKit.RxTime
  public typealias VirtualTimeIntervalUnit = Foundation.TimeInterval
  public func convertFromVirtualTime(_ virtualTime: AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> AliIotConnectKit.RxTime
  public func convertToVirtualTime(_ time: AliIotConnectKit.RxTime) -> AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func convertFromVirtualTimeInterval(_ virtualTimeInterval: AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> Foundation.TimeInterval
  public func convertToVirtualTimeInterval(_ timeInterval: Foundation.TimeInterval) -> AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit
  public func offsetVirtualTime(_ time: AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeUnit, offset: AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func compareVirtualTime(_ lhs: AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeUnit, _ rhs: AliIotConnectKit.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> AliIotConnectKit.VirtualTimeComparison
}
extension AliIotConnectKit.Disposables {
  public static func create() -> any AliIotConnectKit.Disposable
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
extension AliIotConnectKit.ObservableType {
  public func groupBy<Key>(keySelector: @escaping (Self.Element) throws -> Key) -> AliIotConnectKit.Observable<AliIotConnectKit.GroupedObservable<Key, Self.Element>> where Key : Swift.Hashable
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ReplaySubject<Element> : AliIotConnectKit.Observable<Element>, AliIotConnectKit.SubjectType, AliIotConnectKit.ObserverType, AliIotConnectKit.Disposable {
  public typealias SubjectObserverType = AliIotConnectKit.ReplaySubject<Element>
  public var hasObservers: Swift.Bool {
    get
  }
  public func on(_ event: AliIotConnectKit.Event<Element>)
  public func asObserver() -> AliIotConnectKit.ReplaySubject<Element>.SubjectObserverType
  public func dispose()
  public static func create(bufferSize: Swift.Int) -> AliIotConnectKit.ReplaySubject<Element>
  public static func createUnbounded() -> AliIotConnectKit.ReplaySubject<Element>
  public typealias Observer = AliIotConnectKit.ReplaySubject<Element>.SubjectObserverType
  @objc deinit
}
public class CMAC : AliIotConnectKit.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: AliIotConnectKit.CMAC.Error, b: AliIotConnectKit.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: any AliIotConnectKit.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct WearCommonCommand_C : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class Peripheral {
  unowned final public let manager: AliIotConnectKit.CentralManager
  final public let peripheral: CoreBluetooth.CBPeripheral
  public func attach()
  public var isConnected: Swift.Bool {
    get
  }
  public var state: CoreBluetooth.CBPeripheralState {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var identifier: Foundation.UUID {
    get
  }
  public var services: [AliIotConnectKit.Service]? {
    get
  }
  public var canSendWriteWithoutResponse: Swift.Bool {
    get
  }
  public func observeConnection() -> AliIotConnectKit.Observable<Swift.Bool>
  public func establishConnection(options: [Swift.String : Any]? = nil) -> AliIotConnectKit.Observable<AliIotConnectKit.Peripheral>
  public func discoverServices(_ serviceUUIDs: [CoreBluetooth.CBUUID]?) -> AliIotConnectKit.Single<[AliIotConnectKit.Service]>
  public func discoverIncludedServices(_ includedServiceUUIDs: [CoreBluetooth.CBUUID]?, for service: AliIotConnectKit.Service) -> AliIotConnectKit.Single<[AliIotConnectKit.Service]>
  public func discoverCharacteristics(_ characteristicUUIDs: [CoreBluetooth.CBUUID]?, for service: AliIotConnectKit.Service) -> AliIotConnectKit.Single<[AliIotConnectKit.Characteristic]>
  public func observeWrite(for characteristic: AliIotConnectKit.Characteristic? = nil) -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  @available(macOS 10.12, iOS 9.0, *)
  public func maximumWriteValueLength(for type: CoreBluetooth.CBCharacteristicWriteType) -> Swift.Int
  public func writeValue(_ data: Foundation.Data, for characteristic: AliIotConnectKit.Characteristic, type: CoreBluetooth.CBCharacteristicWriteType, canSendWriteWithoutResponseCheckEnabled: Swift.Bool = true) -> AliIotConnectKit.Single<AliIotConnectKit.Characteristic>
  public func observeValueUpdate(for characteristic: AliIotConnectKit.Characteristic? = nil) -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func readValue(for characteristic: AliIotConnectKit.Characteristic) -> AliIotConnectKit.Single<AliIotConnectKit.Characteristic>
  public func observeValueUpdateAndSetNotification(for characteristic: AliIotConnectKit.Characteristic) -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func observeNotifyValue(for characteristic: AliIotConnectKit.Characteristic) -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func discoverDescriptors(for characteristic: AliIotConnectKit.Characteristic) -> AliIotConnectKit.Single<[AliIotConnectKit.Descriptor]>
  public func observeWrite(for descriptor: AliIotConnectKit.Descriptor? = nil) -> AliIotConnectKit.Observable<AliIotConnectKit.Descriptor>
  public func observeValueUpdate(for descriptor: AliIotConnectKit.Descriptor? = nil) -> AliIotConnectKit.Observable<AliIotConnectKit.Descriptor>
  public func readValue(for descriptor: AliIotConnectKit.Descriptor) -> AliIotConnectKit.Single<AliIotConnectKit.Descriptor>
  public func writeValue(_ data: Foundation.Data, for descriptor: AliIotConnectKit.Descriptor) -> AliIotConnectKit.Single<AliIotConnectKit.Descriptor>
  public func readRSSI() -> AliIotConnectKit.Single<(AliIotConnectKit.Peripheral, Swift.Int)>
  public func observeNameUpdate() -> AliIotConnectKit.Observable<(AliIotConnectKit.Peripheral, Swift.String?)>
  public func observeServicesModification() -> AliIotConnectKit.Observable<(AliIotConnectKit.Peripheral, [AliIotConnectKit.Service])>
  public func observeWriteWithoutResponseReadiness() -> AliIotConnectKit.Observable<Swift.Void>
  @available(iOS 11, macOS 10.14, tvOS 11, watchOS 4, *)
  public func openL2CAPChannel(PSM: CoreBluetooth.CBL2CAPPSM) -> AliIotConnectKit.Single<CoreBluetooth.CBL2CAPChannel>
  @objc deinit
}
extension AliIotConnectKit.Peripheral : Swift.Equatable {
}
public func == (lhs: AliIotConnectKit.Peripheral, rhs: AliIotConnectKit.Peripheral) -> Swift.Bool
extension AliIotConnectKit.ObservableType {
  public func toArray() -> AliIotConnectKit.Single<[Self.Element]>
}
extension AliIotConnectKit.CS.BigUInt {
  public func power(_ exponent: Swift.Int) -> AliIotConnectKit.CS.BigUInt
  public func power(_ exponent: AliIotConnectKit.CS.BigUInt, modulus: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
}
extension AliIotConnectKit.CS.BigInt {
  public func power(_ exponent: Swift.Int) -> AliIotConnectKit.CS.BigInt
  public func power(_ exponent: AliIotConnectKit.CS.BigInt, modulus: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
}
extension AliIotConnectKit.CS.BigUInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.CS.BigInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: AliIotConnectKit.PKCS5.PBKDF1.Error, b: AliIotConnectKit.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: AliIotConnectKit.PKCS5.PBKDF1.Variant, b: AliIotConnectKit.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: AliIotConnectKit.PKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: AliIotConnectKit.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
    public func callAsFunction() -> Swift.Array<Swift.UInt8>
  }
}
extension AliIotConnectKit.ObservableType {
  public func throttle(_ dueTime: AliIotConnectKit.RxTimeInterval, latest: Swift.Bool = true, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
@_inheritsConvenienceInitializers final public class SingleAssignmentDisposable : AliIotConnectKit.DisposeBase, AliIotConnectKit.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public func setDisposable(_ disposable: any AliIotConnectKit.Disposable)
  final public func dispose()
  @objc deinit
}
extension AliIotConnectKit.CS.BigUInt {
  public func isStrongProbablePrime(_ base: AliIotConnectKit.CS.BigUInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
extension AliIotConnectKit.CS.BigInt {
  public func isStrongProbablePrime(_ base: AliIotConnectKit.CS.BigInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
extension AliIotConnectKit.ObservableType {
  public func ifEmpty(default: Self.Element) -> AliIotConnectKit.Observable<Self.Element>
}
public enum RxError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case disposed(object: Swift.AnyObject)
  case overflow
  case argumentOutOfRange
  case noElements
  case moreThanOneElement
  case timeout
}
extension AliIotConnectKit.RxError {
  public var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(LPConnectService_C) public class LPConnectService_C : AliIotConnectKit.BleBaseSendService_C {
  @objc public static let shared: AliIotConnectKit.LPConnectService_C
  @objc final public let testNo: Swift.String
  open func disConnect(result: @escaping AliIotConnectKit.fndStateComplete)
  @objc deinit
}
extension AliIotConnectKit.LPConnectService_C : AliIotConnectKit.AliCloudIotDelegate_C, AliIotConnectKit.AliCloudIotSdkInitDelegate_C {
  public func onIotLog(log: Swift.String)
  @objc dynamic public func onInit(successed: Swift.Bool, error: (any Swift.Error)?)
  @objc dynamic public func onDeinit(successed: Swift.Bool, error: (any Swift.Error)?)
  public func onIotDisconnected()
  public func onIotConnected()
  public func onIotConnecting()
  public func onMessageArrived(topic: Swift.String, message: Any?)
  public func onIotMessageArrived(data: Swift.String, message: Swift.String, code: Swift.Int32)
  public func onBusCodeMessageArrived(data: Swift.String, message: Swift.String, code: Swift.Int32)
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
@objc @_inheritsConvenienceInitializers public class BleBaseSendService_C : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class RefCountDisposable : AliIotConnectKit.DisposeBase, AliIotConnectKit.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(disposable: any AliIotConnectKit.Disposable)
  final public func retain() -> any AliIotConnectKit.Disposable
  final public func dispose()
  @objc deinit
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, _ source7: AliIotConnectKit.PrimitiveSequence<Self.Trait, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, _ source7: AliIotConnectKit.PrimitiveSequence<Self.Trait, E7>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, _ source7: AliIotConnectKit.PrimitiveSequence<Self.Trait, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, _ source7: AliIotConnectKit.PrimitiveSequence<Self.Trait, E7>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, _ source7: AliIotConnectKit.PrimitiveSequence<Self.Trait, E7>, _ source8: AliIotConnectKit.PrimitiveSequence<Self.Trait, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, _ source7: AliIotConnectKit.PrimitiveSequence<Self.Trait, E7>, _ source8: AliIotConnectKit.PrimitiveSequence<Self.Trait, E8>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, _ source7: AliIotConnectKit.PrimitiveSequence<Self.Trait, E7>, _ source8: AliIotConnectKit.PrimitiveSequence<Self.Trait, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Any, Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: AliIotConnectKit.PrimitiveSequence<Self.Trait, E1>, _ source2: AliIotConnectKit.PrimitiveSequence<Self.Trait, E2>, _ source3: AliIotConnectKit.PrimitiveSequence<Self.Trait, E3>, _ source4: AliIotConnectKit.PrimitiveSequence<Self.Trait, E4>, _ source5: AliIotConnectKit.PrimitiveSequence<Self.Trait, E5>, _ source6: AliIotConnectKit.PrimitiveSequence<Self.Trait, E6>, _ source7: AliIotConnectKit.PrimitiveSequence<Self.Trait, E7>, _ source8: AliIotConnectKit.PrimitiveSequence<Self.Trait, E8>) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
extension AliIotConnectKit.ObservableType {
  public func flatMap<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> AliIotConnectKit.Observable<Source.Element> where Source : AliIotConnectKit.ObservableConvertibleType
}
extension AliIotConnectKit.ObservableType {
  public func flatMapFirst<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> AliIotConnectKit.Observable<Source.Element> where Source : AliIotConnectKit.ObservableConvertibleType
}
extension AliIotConnectKit.ObservableType where Self.Element : AliIotConnectKit.ObservableConvertibleType {
  public func merge() -> AliIotConnectKit.Observable<Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> AliIotConnectKit.Observable<Self.Element.Element>
}
extension AliIotConnectKit.ObservableType where Self.Element : AliIotConnectKit.ObservableConvertibleType {
  public func concat() -> AliIotConnectKit.Observable<Self.Element.Element>
}
extension AliIotConnectKit.ObservableType {
  public static func merge<Collection>(_ sources: Collection) -> AliIotConnectKit.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element == AliIotConnectKit.Observable<Self.Element>
  public static func merge(_ sources: [AliIotConnectKit.Observable<Self.Element>]) -> AliIotConnectKit.Observable<Self.Element>
  public static func merge(_ sources: AliIotConnectKit.Observable<Self.Element>...) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func concatMap<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> AliIotConnectKit.Observable<Source.Element> where Source : AliIotConnectKit.ObservableConvertibleType
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension AliIotConnectKit.MD5 : AliIotConnectKit.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension AliIotConnectKit.CS.BigUInt {
  public func squareRoot() -> AliIotConnectKit.CS.BigUInt
}
extension AliIotConnectKit.CS.BigInt {
  public func squareRoot() -> AliIotConnectKit.CS.BigInt
}
public enum SubjectLifetimeScope {
  case whileConnected
  case forever
  public static func == (a: AliIotConnectKit.SubjectLifetimeScope, b: AliIotConnectKit.SubjectLifetimeScope) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.ObservableType {
  public func share(replay: Swift.Int = 0, scope: AliIotConnectKit.SubjectLifetimeScope = .whileConnected) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.HMAC {
  convenience public init(key: Swift.String, variant: AliIotConnectKit.HMAC.Variant = .md5) throws
}
extension Swift.String {
  public func decryptBase64ToString(cipher: any AliIotConnectKit.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: any AliIotConnectKit.Cipher) throws -> Swift.Array<Swift.UInt8>
}
extension AliIotConnectKit.CS.BigUInt {
  public static func randomInteger<RNG>(withMaximumWidth width: Swift.Int, using generator: inout RNG) -> AliIotConnectKit.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withMaximumWidth width: Swift.Int) -> AliIotConnectKit.CS.BigUInt
  public static func randomInteger<RNG>(withExactWidth width: Swift.Int, using generator: inout RNG) -> AliIotConnectKit.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withExactWidth width: Swift.Int) -> AliIotConnectKit.CS.BigUInt
  public static func randomInteger<RNG>(lessThan limit: AliIotConnectKit.CS.BigUInt, using generator: inout RNG) -> AliIotConnectKit.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(lessThan limit: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
}
@_inheritsConvenienceInitializers final public class CBCMAC : AliIotConnectKit.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension AliIotConnectKit.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func interval(_ period: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: AliIotConnectKit.RxTimeInterval, period: AliIotConnectKit.RxTimeInterval? = nil, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
public typealias RxTimeInterval = Dispatch.DispatchTimeInterval
public typealias RxTime = Foundation.Date
public protocol SchedulerType : AliIotConnectKit.ImmediateSchedulerType {
  var now: AliIotConnectKit.RxTime { get }
  func scheduleRelative<StateType>(_ state: StateType, dueTime: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  func schedulePeriodic<StateType>(_ state: StateType, startAfter: AliIotConnectKit.RxTimeInterval, period: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any AliIotConnectKit.Disposable
}
extension AliIotConnectKit.SchedulerType {
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: AliIotConnectKit.RxTimeInterval, period: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any AliIotConnectKit.Disposable
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits ≡ 448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: AliIotConnectKit.AES.Error, b: AliIotConnectKit.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: AliIotConnectKit.AES.Variant
  @usableFromInline
  final internal let blockMode: any AliIotConnectKit.BlockMode
  @usableFromInline
  final internal let padding: AliIotConnectKit.Padding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any AliIotConnectKit.BlockMode, padding: AliIotConnectKit.Padding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != AES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = AES.T0[Int(t[0] & 0xff)]
      let lb01 = AES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = AES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = AES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = AES.T0[Int(t[1] & 0xff)]
      let lb11 = AES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = AES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = AES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = AES.T0[Int(t[2] & 0xff)]
      let lb21 = AES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = AES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = AES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = AES.T0[Int(t[3] & 0xff)]
      let lb31 = AES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = AES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = AES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension AliIotConnectKit.AES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension AliIotConnectKit.AES : AliIotConnectKit.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? AES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: AES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
public struct CBC : AliIotConnectKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: AliIotConnectKit.CBC.Error, b: AliIotConnectKit.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: AliIotConnectKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
}
@available(*, deprecated, renamed: "CentralManagerRestoredStateType")
public struct RestoredState {
  public var restoredStateData: [Swift.String : Any] {
    get
  }
  public var centralManager: AliIotConnectKit.CentralManager {
    get
  }
  public var peripherals: [AliIotConnectKit.Peripheral] {
    get
  }
  public var scanOptions: [Swift.String : Swift.AnyObject]? {
    get
  }
  public var services: [AliIotConnectKit.Service] {
    get
  }
}
@_hasMissingDesignatedInitializers final public class MainScheduler : AliIotConnectKit.SerialDispatchQueueScheduler {
  public init()
  public static let instance: AliIotConnectKit.MainScheduler
  public static let asyncInstance: AliIotConnectKit.SerialDispatchQueueScheduler
  final public class func ensureExecutingOnScheduler(errorMessage: Swift.String? = nil)
  final public class func ensureRunningOnMainThread(errorMessage: Swift.String? = nil)
  @objc deinit
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64(options: Foundation.Data.Base64EncodingOptions = []) -> Swift.String
  public init(base64: Swift.String, options: Foundation.Data.Base64DecodingOptions = .ignoreUnknownCharacters)
}
public enum Event<Element> {
  case next(Element)
  case error(any Swift.Error)
  case completed
}
extension AliIotConnectKit.Event : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AliIotConnectKit.Event {
  public var isStopEvent: Swift.Bool {
    get
  }
  public var element: Element? {
    get
  }
  public var error: (any Swift.Error)? {
    get
  }
  public var isCompleted: Swift.Bool {
    get
  }
}
extension AliIotConnectKit.Event {
  public func map<Result>(_ transform: (Element) throws -> Result) -> AliIotConnectKit.Event<Result>
}
public protocol EventConvertible {
  associatedtype Element
  @available(*, deprecated, renamed: "Element")
  typealias ElementType = Self.Element
  var event: AliIotConnectKit.Event<Self.Element> { get }
}
extension AliIotConnectKit.Event : AliIotConnectKit.EventConvertible {
  public var event: AliIotConnectKit.Event<Element> {
    get
  }
}
public protocol ObservableConvertibleType {
  associatedtype Element
  @available(*, deprecated, renamed: "Element")
  typealias E = Self.Element
  func asObservable() -> AliIotConnectKit.Observable<Self.Element>
}
public struct AdvertisementData {
  public let advertisementData: [Swift.String : Any]
  public init(advertisementData: [Swift.String : Any])
  public var localName: Swift.String? {
    get
  }
  public var manufacturerData: Foundation.Data? {
    get
  }
  public var serviceData: [CoreBluetooth.CBUUID : Foundation.Data]? {
    get
  }
  public var serviceUUIDs: [CoreBluetooth.CBUUID]? {
    get
  }
  public var overflowServiceUUIDs: [CoreBluetooth.CBUUID]? {
    get
  }
  public var txPowerLevel: Foundation.NSNumber? {
    get
  }
  public var isConnectable: Swift.Bool? {
    get
  }
  public var solicitedServiceUUIDs: [CoreBluetooth.CBUUID]? {
    get
  }
}
public protocol ImmediateSchedulerType {
  func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
}
extension AliIotConnectKit.ImmediateSchedulerType {
  public func scheduleRecursive<State>(_ state: State, action: @escaping (_ state: State, _ recurse: (State) -> Swift.Void) -> Swift.Void) -> any AliIotConnectKit.Disposable
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: AliIotConnectKit.BlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: AliIotConnectKit.BlockModeOption
  @usableFromInline
  internal static let paddingRequired: AliIotConnectKit.BlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: AliIotConnectKit.BlockModeOption
  public typealias ArrayLiteralElement = AliIotConnectKit.BlockModeOption
  public typealias Element = AliIotConnectKit.BlockModeOption
  public typealias RawValue = Swift.Int
}
@available(*, deprecated, renamed: "OnWillRestoreCentralManagerState")
public typealias OnWillRestoreState = (AliIotConnectKit.RestoredState) -> Swift.Void
public typealias OnWillRestoreCentralManagerState = (AliIotConnectKit.CentralManagerRestoredState) -> Swift.Void
extension AliIotConnectKit.CentralManager {
  @available(*, deprecated, renamed: "CentralManager.init(queue:options:onWillRestoreCentralManagerState:)")
  convenience public init(queue: Dispatch.DispatchQueue = .main, options: [Swift.String : Swift.AnyObject]? = nil, cbCentralManager: CoreBluetooth.CBCentralManager? = nil, onWillRestoreState: AliIotConnectKit.OnWillRestoreState? = nil)
  convenience public init(queue: Dispatch.DispatchQueue = .main, options: [Swift.String : Swift.AnyObject]? = nil, cbCentralManager: CoreBluetooth.CBCentralManager? = nil, onWillRestoreCentralManagerState: AliIotConnectKit.OnWillRestoreCentralManagerState? = nil)
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension AliIotConnectKit.Updatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
public struct PeripheralManagerRestoredState {
  public let restoredStateData: [Swift.String : Any]
  public var services: [CoreBluetooth.CBMutableService] {
    get
  }
  public var advertisementData: [Swift.String : Any]? {
    get
  }
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
public class BlockDecryptor : AliIotConnectKit.Cryptor, AliIotConnectKit.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: AliIotConnectKit.Padding
  @usableFromInline
  internal var worker: any AliIotConnectKit.CipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: AliIotConnectKit.Padding, _ worker: any AliIotConnectKit.CipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
extension AliIotConnectKit.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: AliIotConnectKit.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: any AliIotConnectKit.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: any AliIotConnectKit.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: any AliIotConnectKit.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
extension AliIotConnectKit.ObservableType {
  public func takeWhile(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
}
public typealias DisconnectionReason = Swift.Error
@_hasMissingDesignatedInitializers public class CentralManager : AliIotConnectKit.ManagerType {
  final public let manager: CoreBluetooth.CBCentralManager
  @available(*, deprecated, renamed: "CentralManager.manager")
  public var centralManager: CoreBluetooth.CBCentralManager {
    get
  }
  convenience public init(queue: Dispatch.DispatchQueue = .main, options: [Swift.String : Swift.AnyObject]? = nil, cbCentralManager: CoreBluetooth.CBCentralManager? = nil)
  public func attach()
  public var state: AliIotConnectKit.BluetoothState {
    get
  }
  public func observeState() -> AliIotConnectKit.Observable<AliIotConnectKit.BluetoothState>
  public func observeStateWithInitialValue() -> AliIotConnectKit.Observable<AliIotConnectKit.BluetoothState>
  public var isScanInProgress: Swift.Bool {
    get
  }
  public func scanForPeripherals(withServices serviceUUIDs: [CoreBluetooth.CBUUID]?, options: [Swift.String : Any]? = nil) -> AliIotConnectKit.Observable<AliIotConnectKit.ScannedPeripheral>
  public func establishConnection(_ peripheral: AliIotConnectKit.Peripheral, options: [Swift.String : Any]? = nil) -> AliIotConnectKit.Observable<AliIotConnectKit.Peripheral>
  public func retrieveConnectedPeripherals(withServices serviceUUIDs: [CoreBluetooth.CBUUID]) -> [AliIotConnectKit.Peripheral]
  public func retrievePeripherals(withIdentifiers identifiers: [Foundation.UUID]) -> [AliIotConnectKit.Peripheral]
  public func observeConnect(for peripheral: AliIotConnectKit.Peripheral? = nil) -> AliIotConnectKit.Observable<AliIotConnectKit.Peripheral>
  public func observeDisconnect(for peripheral: AliIotConnectKit.Peripheral? = nil) -> AliIotConnectKit.Observable<(AliIotConnectKit.Peripheral, (any Swift.Error)?)>
  @available(iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public func observeANCSAuthorized(for peripheral: AliIotConnectKit.Peripheral) -> AliIotConnectKit.Observable<Swift.Bool>
  public typealias Manager = CoreBluetooth.CBCentralManager
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public func takeUntil<Source>(_ other: Source) -> AliIotConnectKit.Observable<Self.Element> where Source : AliIotConnectKit.ObservableType
  public func takeUntil(_ behavior: AliIotConnectKit.TakeUntilBehavior, predicate: @escaping (Self.Element) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
}
public enum TakeUntilBehavior {
  case inclusive
  case exclusive
  public static func == (a: AliIotConnectKit.TakeUntilBehavior, b: AliIotConnectKit.TakeUntilBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.ObservableType {
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> AliIotConnectKit.Observable<Result>
}
public typealias RestoredAdvertisementData = [Swift.String : Any]
public enum StartAdvertisingResult {
  case started
  case attachedToExternalAdvertising(AliIotConnectKit.RestoredAdvertisementData?)
}
@usableFromInline
final internal class StreamDecryptor : AliIotConnectKit.Cryptor, AliIotConnectKit.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any AliIotConnectKit.CipherModeWorker
  @usableFromInline
  final internal let padding: AliIotConnectKit.Padding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: AliIotConnectKit.Padding, _ worker: any AliIotConnectKit.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
extension AliIotConnectKit.ObservableType {
  public static func generate(initialState: Self.Element, condition: @escaping (Self.Element) throws -> Swift.Bool, scheduler: any AliIotConnectKit.ImmediateSchedulerType = CurrentThreadScheduler.instance, iterate: @escaping (Self.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func timeout(_ dueTime: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
  public func timeout<Source>(_ dueTime: AliIotConnectKit.RxTimeInterval, other: Source, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element> where Source : AliIotConnectKit.ObservableConvertibleType, Self.Element == Source.Element
}
extension AliIotConnectKit.ObservableType {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> AliIotConnectKit.Observable<(O1.Element, O2.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType, O7 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType, O7 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType, O7 : AliIotConnectKit.ObservableType, O8 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType, O7 : AliIotConnectKit.ObservableType, O8 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public func takeLast(_ count: Swift.Int) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> AliIotConnectKit.Observable<Result>
}
public protocol Disposable {
  func dispose()
}
extension AliIotConnectKit.Disposable {
  public func disposed(by bag: AliIotConnectKit.DisposeBag)
}
@_inheritsConvenienceInitializers final public class DisposeBag : AliIotConnectKit.DisposeBase {
  public init()
  final public func insert(_ disposable: any AliIotConnectKit.Disposable)
  @objc deinit
}
extension AliIotConnectKit.DisposeBag {
  convenience public init(disposing disposables: any AliIotConnectKit.Disposable...)
  convenience public init(disposing disposables: [any AliIotConnectKit.Disposable])
  final public func insert(_ disposables: any AliIotConnectKit.Disposable...)
  final public func insert(_ disposables: [any AliIotConnectKit.Disposable])
}
extension AliIotConnectKit.ObservableType {
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (AliIotConnectKit.Observable<Error>) -> TriggerObservable) -> AliIotConnectKit.Observable<Self.Element> where TriggerObservable : AliIotConnectKit.ObservableType, Error : Swift.Error
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (AliIotConnectKit.Observable<any Swift.Error>) -> TriggerObservable) -> AliIotConnectKit.Observable<Self.Element> where TriggerObservable : AliIotConnectKit.ObservableType
}
@_hasMissingDesignatedInitializers final public class ConcurrentMainScheduler : AliIotConnectKit.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  final public var now: Foundation.Date {
    get
  }
  public static let instance: AliIotConnectKit.ConcurrentMainScheduler
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  final public func schedulePeriodic<StateType>(_ state: StateType, startAfter: AliIotConnectKit.RxTimeInterval, period: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any AliIotConnectKit.Disposable
  @objc deinit
}
extension AliIotConnectKit.ObservableType where Self.Element : AliIotConnectKit.EventConvertible {
  public func dematerialize() -> AliIotConnectKit.Observable<Self.Element.Element>
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : AliIotConnectKit.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
extension AliIotConnectKit.CS.BigUInt {
  public func greatestCommonDivisor(with b: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
  public func inverse(_ modulus: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt?
}
extension AliIotConnectKit.CS.BigInt {
  public func greatestCommonDivisor(with b: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public func inverse(_ modulus: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt?
}
@_hasMissingDesignatedInitializers public class Service {
  final public let service: CoreBluetooth.CBService
  final public let peripheral: AliIotConnectKit.Peripheral
  public var isPrimary: Swift.Bool {
    get
  }
  public var uuid: CoreBluetooth.CBUUID {
    get
  }
  public var includedServices: [AliIotConnectKit.Service]? {
    get
  }
  public var characteristics: [AliIotConnectKit.Characteristic]? {
    get
  }
  public func discoverCharacteristics(_ characteristicUUIDs: [CoreBluetooth.CBUUID]?) -> AliIotConnectKit.Single<[AliIotConnectKit.Characteristic]>
  public func discoverIncludedServices(_ includedServiceUUIDs: [CoreBluetooth.CBUUID]?) -> AliIotConnectKit.Single<[AliIotConnectKit.Service]>
  @objc deinit
}
extension AliIotConnectKit.Service : Swift.Equatable {
}
public func == (lhs: AliIotConnectKit.Service, rhs: AliIotConnectKit.Service) -> Swift.Bool
extension AliIotConnectKit.ObservableType {
  public func materialize() -> AliIotConnectKit.Observable<AliIotConnectKit.Event<Self.Element>>
}
@_hasMissingDesignatedInitializers public class Observable<Element> : AliIotConnectKit.ObservableType {
  public func subscribe<Observer>(_ observer: Observer) -> any AliIotConnectKit.Disposable where Element == Observer.Element, Observer : AliIotConnectKit.ObserverType
  public func asObservable() -> AliIotConnectKit.Observable<Element>
  @objc deinit
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.Bit {
  @inlinable internal func inverted() -> AliIotConnectKit.Bit {
    self == .zero ? .one : .zero
  }
}
public protocol AliCloudIotDelegate_C {
  func onIotDisconnected()
  func onIotConnected()
  func onIotConnecting()
  func onMessageArrived(topic: Swift.String, message: Any?)
  func onIotMessageArrived(data: Swift.String, message: Swift.String, code: Swift.Int32)
  func onBusCodeMessageArrived(data: Swift.String, message: Swift.String, code: Swift.Int32)
  func onIotLog(log: Swift.String)
}
@_inheritsConvenienceInitializers public class FileDestination : AliIotConnectKit.BaseDestination {
  public var logFileURL: Foundation.URL?
  public var syncAfterEachWrite: Swift.Bool
  public var colored: Swift.Bool {
    get
    set
  }
  override public var defaultHashValue: Swift.Int {
    get
  }
  override public init()
  override public func send(_ level: AliIotConnectKit.SwiftyBeaver.Level, msg: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, context: Any? = nil) -> Swift.String?
  @objc deinit
  public func deleteLogFile() -> Swift.Bool
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: AliIotConnectKit.CTR.Error, b: AliIotConnectKit.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: AliIotConnectKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
}
final public class ScheduledDisposable : AliIotConnectKit.Cancelable {
  final public let scheduler: any AliIotConnectKit.ImmediateSchedulerType
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(scheduler: any AliIotConnectKit.ImmediateSchedulerType, disposable: any AliIotConnectKit.Disposable)
  final public func dispose()
  @objc deinit
}
extension AliIotConnectKit.RSA : AliIotConnectKit.Signature {
  final public func sign(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func sign(_ bytes: Swift.Array<Swift.UInt8>, variant: AliIotConnectKit.RSA.SignatureVariant) throws -> Swift.Array<Swift.UInt8>
  final public func verify(signature: Swift.ArraySlice<Swift.UInt8>, for expectedData: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Bool
  final public func verify(signature: Swift.Array<Swift.UInt8>, for bytes: Swift.Array<Swift.UInt8>, variant: AliIotConnectKit.RSA.SignatureVariant) throws -> Swift.Bool
}
extension AliIotConnectKit.RSA {
  public enum SignatureVariant {
    case raw
    case message_pkcs1v15_MD5
    case message_pkcs1v15_SHA1
    case message_pkcs1v15_SHA224
    case message_pkcs1v15_SHA256
    case message_pkcs1v15_SHA384
    case message_pkcs1v15_SHA512
    case message_pkcs1v15_SHA512_224
    case message_pkcs1v15_SHA512_256
    case digest_pkcs1v15_RAW
    case digest_pkcs1v15_MD5
    case digest_pkcs1v15_SHA1
    case digest_pkcs1v15_SHA224
    case digest_pkcs1v15_SHA256
    case digest_pkcs1v15_SHA384
    case digest_pkcs1v15_SHA512
    case digest_pkcs1v15_SHA512_224
    case digest_pkcs1v15_SHA512_256
    public static func == (a: AliIotConnectKit.RSA.SignatureVariant, b: AliIotConnectKit.RSA.SignatureVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public class HistoricalScheduler : AliIotConnectKit.VirtualTimeScheduler<AliIotConnectKit.HistoricalSchedulerTimeConverter> {
  public init(initialClock: AliIotConnectKit.RxTime = Date(timeIntervalSince1970: 0))
  @objc deinit
}
public protocol ObservableType : AliIotConnectKit.ObservableConvertibleType {
  func subscribe<Observer>(_ observer: Observer) -> any AliIotConnectKit.Disposable where Observer : AliIotConnectKit.ObserverType, Self.Element == Observer.Element
}
extension AliIotConnectKit.ObservableType {
  public func asObservable() -> AliIotConnectKit.Observable<Self.Element>
}
@usableFromInline
final internal class BlockEncryptor : AliIotConnectKit.Cryptor, AliIotConnectKit.Updatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: AliIotConnectKit.Padding, _ worker: any AliIotConnectKit.CipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension AliIotConnectKit.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: AliIotConnectKit.Padding = .pkcs7) throws
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: AliIotConnectKit.ChaCha20.Error, b: AliIotConnectKit.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension AliIotConnectKit.ChaCha20 : AliIotConnectKit.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension AliIotConnectKit.ChaCha20 {
  public struct ChaChaEncryptor : AliIotConnectKit.Cryptor, AliIotConnectKit.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension AliIotConnectKit.ChaCha20 {
  public struct ChaChaDecryptor : AliIotConnectKit.Cryptor, AliIotConnectKit.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension AliIotConnectKit.ChaCha20 : AliIotConnectKit.Cryptors {
  final public func makeEncryptor() -> any AliIotConnectKit.Cryptor & AliIotConnectKit.Updatable
  final public func makeDecryptor() -> any AliIotConnectKit.Cryptor & AliIotConnectKit.Updatable
}
final public class GoogleCloudDestination : AliIotConnectKit.BaseDestination {
  public init(serviceName: Swift.String)
  override final public var asynchronously: Swift.Bool {
    get
    set
  }
  override final public func send(_ level: AliIotConnectKit.SwiftyBeaver.Level, msg: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, context: Any? = nil) -> Swift.String?
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public func window(timeSpan: AliIotConnectKit.RxTimeInterval, count: Swift.Int, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<AliIotConnectKit.Observable<Self.Element>>
}
extension AliIotConnectKit.ObservableType {
  public func flatMapLatest<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> AliIotConnectKit.Observable<Source.Element> where Source : AliIotConnectKit.ObservableConvertibleType
}
extension AliIotConnectKit.ObservableType where Self.Element : AliIotConnectKit.ObservableConvertibleType {
  public func switchLatest() -> AliIotConnectKit.Observable<Self.Element.Element>
}
public typealias checkFgsStateComplete = (_ isSuccess: Swift.Bool, _ data: [Swift.String : Any]) -> ()
public typealias fndStateComplete = (_ isSuccess: Swift.Bool, _ data: [Swift.String : Any]) -> ()
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers public class AliConnectMananger_C : ObjectiveC.NSObject {
  @objc public static let shared: AliIotConnectKit.AliConnectMananger_C
  @objc public var bleSendDataDelegate: (any AliIotConnectKit.BleNeedSendDataDelegate_C)?
  @objc public var iotStateDelegate: (any AliIotConnectKit.IotStateDelatege_C)? {
    @objc get
    @objc set
  }
  @objc public var appVersion: Swift.String? {
    @objc get
    @objc set
  }
  @objc open func bleDataReceived(data: Foundation.Data)
  @objc open func checkFgsState(result: @escaping AliIotConnectKit.checkFgsStateComplete)
  @objc open func startConnectLpState(result: @escaping AliIotConnectKit.fndStateComplete)
  @objc open func disConnect(result: @escaping AliIotConnectKit.fndStateComplete)
  @objc open func uploadFile(fileName: Swift.String, content: Foundation.Data)
  @objc deinit
}
extension AliIotConnectKit.CS.BigUInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension AliIotConnectKit.CS.BigInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension Swift.String {
  public init(_ v: AliIotConnectKit.CS.BigUInt)
  public init(_ v: AliIotConnectKit.CS.BigUInt, radix: Swift.Int, uppercase: Swift.Bool = false)
  public init(_ value: AliIotConnectKit.CS.BigInt, radix: Swift.Int = 10, uppercase: Swift.Bool = false)
}
extension AliIotConnectKit.CS.BigUInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension AliIotConnectKit.CS.BigInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension AliIotConnectKit.CS.BigUInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AliIotConnectKit.CS.BigInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AliIotConnectKit.CS.BigUInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
extension AliIotConnectKit.CS.BigInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
extension AliIotConnectKit.CS.BigUInt {
  public mutating func multiply(byWord y: AliIotConnectKit.CS.BigUInt.Word)
  public func multiplied(byWord y: AliIotConnectKit.CS.BigUInt.Word) -> AliIotConnectKit.CS.BigUInt
  public mutating func multiplyAndAdd(_ x: AliIotConnectKit.CS.BigUInt, _ y: AliIotConnectKit.CS.BigUInt.Word, shiftedBy shift: Swift.Int = 0)
  public func multiplied(by y: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
  public static var directMultiplicationLimit: Swift.Int
  public static func * (x: AliIotConnectKit.CS.BigUInt, y: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
  public static func *= (a: inout AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt)
}
extension AliIotConnectKit.CS.BigInt {
  public static func * (a: AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func *= (a: inout AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt)
}
extension AliIotConnectKit.ObservableType {
  public static func combineLatest<Collection>(_ collection: Collection, resultSelector: @escaping ([Collection.Element.Element]) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element : AliIotConnectKit.ObservableType
  public static func combineLatest<Collection>(_ collection: Collection) -> AliIotConnectKit.Observable<[Self.Element]> where Collection : Swift.Collection, Self.Element == Collection.Element.Element, Collection.Element : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == AliIotConnectKit.CompletableTrait {
  public func andThen<Element>(_ second: AliIotConnectKit.Single<Element>) -> AliIotConnectKit.Single<Element>
  public func andThen<Element>(_ second: AliIotConnectKit.Maybe<Element>) -> AliIotConnectKit.Maybe<Element>
  public func andThen(_ second: AliIotConnectKit.Completable) -> AliIotConnectKit.Completable
  public func andThen<Element>(_ second: AliIotConnectKit.Observable<Element>) -> AliIotConnectKit.Observable<Element>
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> any AliIotConnectKit.Cryptor & AliIotConnectKit.Updatable
  func makeDecryptor() throws -> any AliIotConnectKit.Cryptor & AliIotConnectKit.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension AliIotConnectKit.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension AliIotConnectKit.CS.BigUInt : Swift.Comparable {
  public static func compare(_ a: AliIotConnectKit.CS.BigUInt, _ b: AliIotConnectKit.CS.BigUInt) -> Foundation.ComparisonResult
  public static func == (a: AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt) -> Swift.Bool
  public static func < (a: AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt) -> Swift.Bool
}
extension AliIotConnectKit.CS.BigInt {
  public static func == (a: AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt) -> Swift.Bool
  public static func < (a: AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt) -> Swift.Bool
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: AliIotConnectKit.BlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
extension AliIotConnectKit.ObservableType {
  public func single() -> AliIotConnectKit.Observable<Self.Element>
  public func single(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: AliIotConnectKit.HKDF.Error, b: AliIotConnectKit.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: AliIotConnectKit.HMAC.Variant = .sha2(.sha256)) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
  public func callAsFunction() throws -> Swift.Array<Swift.UInt8>
}
extension AliIotConnectKit.CS.BigUInt {
  public static func >>= <Other>(lhs: inout AliIotConnectKit.CS.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout AliIotConnectKit.CS.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: AliIotConnectKit.CS.BigUInt, rhs: Other) -> AliIotConnectKit.CS.BigUInt where Other : Swift.BinaryInteger
  public static func << <Other>(lhs: AliIotConnectKit.CS.BigUInt, rhs: Other) -> AliIotConnectKit.CS.BigUInt where Other : Swift.BinaryInteger
}
extension AliIotConnectKit.CS.BigInt {
  public static func &<< (left: AliIotConnectKit.CS.BigInt, right: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func &<<= (left: inout AliIotConnectKit.CS.BigInt, right: AliIotConnectKit.CS.BigInt)
  public static func &>> (left: AliIotConnectKit.CS.BigInt, right: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func &>>= (left: inout AliIotConnectKit.CS.BigInt, right: AliIotConnectKit.CS.BigInt)
  public static func << <Other>(lhs: AliIotConnectKit.CS.BigInt, rhs: Other) -> AliIotConnectKit.CS.BigInt where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout AliIotConnectKit.CS.BigInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: AliIotConnectKit.CS.BigInt, rhs: Other) -> AliIotConnectKit.CS.BigInt where Other : Swift.BinaryInteger
  public static func >>= <Other>(lhs: inout AliIotConnectKit.CS.BigInt, rhs: Other) where Other : Swift.BinaryInteger
}
extension AliIotConnectKit.ObservableType {
  public static func from(optional: Self.Element?) -> AliIotConnectKit.Observable<Self.Element>
  public static func from(optional: Self.Element?, scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func scan<A>(into seed: A, accumulator: @escaping (inout A, Self.Element) throws -> Swift.Void) -> AliIotConnectKit.Observable<A>
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A) -> AliIotConnectKit.Observable<A>
}
public enum Hooks {
  public static var recordCallStackOnError: Swift.Bool
}
public protocol ObserverType {
  associatedtype Element
  @available(*, deprecated, renamed: "Element")
  typealias E = Self.Element
  func on(_ event: AliIotConnectKit.Event<Self.Element>)
}
extension AliIotConnectKit.ObserverType {
  public func onNext(_ element: Self.Element)
  public func onCompleted()
  public func onError(_ error: any Swift.Error)
}
@_inheritsConvenienceInitializers public class ConsoleDestination : AliIotConnectKit.BaseDestination {
  public var useNSLog: Swift.Bool
  public var useTerminalColors: Swift.Bool {
    get
    set
  }
  override public var defaultHashValue: Swift.Int {
    get
  }
  override public init()
  override public func send(_ level: AliIotConnectKit.SwiftyBeaver.Level, msg: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, context: Any? = nil) -> Swift.String?
  @objc deinit
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension AliIotConnectKit.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
final public class HMAC : AliIotConnectKit.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: AliIotConnectKit.HMAC.Error, b: AliIotConnectKit.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case md5
    case sha1
    case sha2(AliIotConnectKit.SHA2.Variant)
    case sha3(AliIotConnectKit.SHA3.Variant)
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha256, sha384, sha512
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: AliIotConnectKit.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct GroupedObservable<Key, Element> : AliIotConnectKit.ObservableType {
  public let key: Key
  public init(key: Key, source: AliIotConnectKit.Observable<Element>)
  public func subscribe<Observer>(_ observer: Observer) -> any AliIotConnectKit.Disposable where Element == Observer.Element, Observer : AliIotConnectKit.ObserverType
  public func asObservable() -> AliIotConnectKit.Observable<Element>
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
public enum SingleTrait {
}
public typealias Single<Element> = AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.SingleTrait, Element>
public enum SingleEvent<Element> {
  case success(Element)
  case error(any Swift.Error)
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public typealias SingleObserver = (AliIotConnectKit.SingleEvent<Self.Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.SingleObserver) -> any AliIotConnectKit.Disposable) -> AliIotConnectKit.Single<Self.Element>
  public func subscribe(_ observer: @escaping (AliIotConnectKit.SingleEvent<Self.Element>) -> Swift.Void) -> any AliIotConnectKit.Disposable
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil) -> any AliIotConnectKit.Disposable
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public static func just(_ element: Self.Element) -> AliIotConnectKit.Single<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.Single<Self.Element>
  public static func error(_ error: any Swift.Error) -> AliIotConnectKit.Single<Self.Element>
  public static func never() -> AliIotConnectKit.Single<Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  public func `do`(onSuccess: ((Self.Element) throws -> Swift.Void)? = nil, afterSuccess: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> AliIotConnectKit.Single<Self.Element>
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> AliIotConnectKit.Maybe<Self.Element>
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> AliIotConnectKit.Single<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> AliIotConnectKit.Maybe<Result>
  public func flatMap<Result>(_ selector: @escaping (Self.Element) throws -> AliIotConnectKit.Single<Result>) -> AliIotConnectKit.Single<Result>
  public func flatMapMaybe<Result>(_ selector: @escaping (Self.Element) throws -> AliIotConnectKit.Maybe<Result>) -> AliIotConnectKit.Maybe<Result>
  public func flatMapCompletable(_ selector: @escaping (Self.Element) throws -> AliIotConnectKit.Completable) -> AliIotConnectKit.Completable
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Self.Element]) throws -> Result) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Result> where Collection : Swift.Collection, Collection.Element == AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.SingleTrait, Self.Element>
  public static func zip<Collection>(_ collection: Collection) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, [Self.Element]> where Collection : Swift.Collection, Collection.Element == AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.SingleTrait, Self.Element>
  public func catchErrorJustReturn(_ element: Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
  public func asMaybe() -> AliIotConnectKit.Maybe<Self.Element>
  public func asCompletable() -> AliIotConnectKit.Completable
}
extension AliIotConnectKit.ObservableType {
  public static func just(_ element: Self.Element) -> AliIotConnectKit.Observable<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func range(start: Self.Element, count: Self.Element, scheduler: any AliIotConnectKit.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> AliIotConnectKit.Observable<Self.Element>
}
public struct Disposables {
}
extension AliIotConnectKit.ObservableType {
  public func sample<Source>(_ sampler: Source) -> AliIotConnectKit.Observable<Self.Element> where Source : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public func subscribeOn(_ scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension Swift.String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: AliIotConnectKit.SHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: any AliIotConnectKit.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: any AliIotConnectKit.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : AliIotConnectKit.Authenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
extension AliIotConnectKit.CS.BigUInt {
  public func quotientAndRemainder(dividingBy y: AliIotConnectKit.CS.BigUInt) -> (quotient: AliIotConnectKit.CS.BigUInt, remainder: AliIotConnectKit.CS.BigUInt)
  public static func / (x: AliIotConnectKit.CS.BigUInt, y: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
  public static func % (x: AliIotConnectKit.CS.BigUInt, y: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
  public static func /= (x: inout AliIotConnectKit.CS.BigUInt, y: AliIotConnectKit.CS.BigUInt)
  public static func %= (x: inout AliIotConnectKit.CS.BigUInt, y: AliIotConnectKit.CS.BigUInt)
}
extension AliIotConnectKit.CS.BigInt {
  public func quotientAndRemainder(dividingBy y: AliIotConnectKit.CS.BigInt) -> (quotient: AliIotConnectKit.CS.BigInt, remainder: AliIotConnectKit.CS.BigInt)
  public static func / (a: AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func % (a: AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public func modulus(_ mod: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
}
extension AliIotConnectKit.CS.BigInt {
  public static func /= (a: inout AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt)
  public static func %= (a: inout AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt)
}
extension AliIotConnectKit.ObservableType {
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, observableFactory: @escaping (Resource) throws -> AliIotConnectKit.Observable<Self.Element>) -> AliIotConnectKit.Observable<Self.Element> where Resource : AliIotConnectKit.Disposable
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: AliIotConnectKit.CCM.Error, b: AliIotConnectKit.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: AliIotConnectKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
}
extension AliIotConnectKit.ObservableType {
  public static func never() -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.CS.BigUInt {
  public static func + (a: AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
  public static func += (a: inout AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt)
}
extension AliIotConnectKit.CS.BigInt {
  public static func + (a: AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func += (a: inout AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt)
}
extension AliIotConnectKit.CS.BigUInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
extension AliIotConnectKit.CS.BigInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
extension AliIotConnectKit.ObservableType {
  public func ifEmpty(switchTo other: AliIotConnectKit.Observable<Self.Element>) -> AliIotConnectKit.Observable<Self.Element>
}
public struct OFB : AliIotConnectKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: AliIotConnectKit.OFB.Error, b: AliIotConnectKit.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: AliIotConnectKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
}
@objc public protocol AliCloudIotSdkInitDelegate_C {
  @objc func onInit(successed: Swift.Bool, error: (any Swift.Error)?)
  @objc func onDeinit(successed: Swift.Bool, error: (any Swift.Error)?)
}
public enum SignatureError : Swift.Error {
  case sign
  case verify
  public static func == (a: AliIotConnectKit.SignatureError, b: AliIotConnectKit.SignatureError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Signature : AnyObject {
  var keySize: Swift.Int { get }
  func sign(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func sign(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func verify(signature: Swift.ArraySlice<Swift.UInt8>, for expectedData: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Bool
  func verify(signature: Swift.Array<Swift.UInt8>, for expectedData: Swift.Array<Swift.UInt8>) throws -> Swift.Bool
}
extension AliIotConnectKit.Signature {
  public func sign(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func verify(signature: Swift.Array<Swift.UInt8>, for expectedData: Swift.Array<Swift.UInt8>) throws -> Swift.Bool
}
public struct CentralManagerRestoredState {
  public let restoredStateData: [Swift.String : Any]
  unowned public let centralManager: AliIotConnectKit.CentralManager
  public var peripherals: [AliIotConnectKit.Peripheral] {
    get
  }
  public var scanOptions: [Swift.String : Swift.AnyObject]? {
    get
  }
  public var services: [AliIotConnectKit.Service] {
    get
  }
}
extension AliIotConnectKit.CS.BigUInt {
  prefix public static func ~ (a: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
  public static func |= (a: inout AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt)
  public static func &= (a: inout AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt)
  public static func ^= (a: inout AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt)
}
extension AliIotConnectKit.CS.BigInt {
  prefix public static func ~ (x: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func & (lhs: inout AliIotConnectKit.CS.BigInt, rhs: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func | (lhs: inout AliIotConnectKit.CS.BigInt, rhs: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func ^ (lhs: inout AliIotConnectKit.CS.BigInt, rhs: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func &= (lhs: inout AliIotConnectKit.CS.BigInt, rhs: AliIotConnectKit.CS.BigInt)
  public static func |= (lhs: inout AliIotConnectKit.CS.BigInt, rhs: AliIotConnectKit.CS.BigInt)
  public static func ^= (lhs: inout AliIotConnectKit.CS.BigInt, rhs: AliIotConnectKit.CS.BigInt)
}
public struct Reactive<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol ReactiveCompatible {
  associatedtype ReactiveBase
  @available(*, deprecated, renamed: "ReactiveBase")
  typealias CompatibleType = Self.ReactiveBase
  static var rx: AliIotConnectKit.Reactive<Self.ReactiveBase>.Type { get set }
  var rx: AliIotConnectKit.Reactive<Self.ReactiveBase> { get set }
}
extension AliIotConnectKit.ReactiveCompatible {
  public static var rx: AliIotConnectKit.Reactive<Self>.Type {
    get
    set
  }
  public var rx: AliIotConnectKit.Reactive<Self> {
    get
    set
  }
}
extension ObjectiveC.NSObject : AliIotConnectKit.ReactiveCompatible {
  public typealias ReactiveBase = ObjectiveC.NSObject
}
extension AliIotConnectKit.CS.BigUInt {
  public subscript(bitAt index: Swift.Int) -> Swift.Bool {
    get
    set
  }
}
extension AliIotConnectKit.CS.BigUInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension AliIotConnectKit.CS.BigInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension AliIotConnectKit.CS.BigUInt {
  public struct Words : Swift.RandomAccessCollection {
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> AliIotConnectKit.CS.BigUInt.Word {
      get
    }
    public typealias Element = AliIotConnectKit.CS.BigUInt.Word
    public typealias Index = Swift.Int
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias Iterator = Swift.IndexingIterator<AliIotConnectKit.CS.BigUInt.Words>
    public typealias SubSequence = Swift.Slice<AliIotConnectKit.CS.BigUInt.Words>
  }
  public var words: AliIotConnectKit.CS.BigUInt.Words {
    get
  }
  public init<Words>(words: Words) where Words : Swift.Sequence, Words.Element == Swift.UInt
}
extension AliIotConnectKit.CS.BigInt {
  public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.CountableRange<Swift.Int>
    public var count: Swift.Int {
      get
    }
    public var indices: AliIotConnectKit.CS.BigInt.Words.Indices {
      get
    }
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      get
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<AliIotConnectKit.CS.BigInt.Words>
    public typealias SubSequence = Swift.Slice<AliIotConnectKit.CS.BigInt.Words>
  }
  public var words: AliIotConnectKit.CS.BigInt.Words {
    get
  }
  public init<S>(words: S) where S : Swift.Sequence, S.Element == Swift.UInt
}
extension AliIotConnectKit.ObservableType {
  public static func error(_ error: any Swift.Error) -> AliIotConnectKit.Observable<Self.Element>
}
public protocol VirtualTimeConverterType {
  associatedtype VirtualTimeUnit
  associatedtype VirtualTimeIntervalUnit
  func convertFromVirtualTime(_ virtualTime: Self.VirtualTimeUnit) -> AliIotConnectKit.RxTime
  func convertToVirtualTime(_ time: AliIotConnectKit.RxTime) -> Self.VirtualTimeUnit
  func convertFromVirtualTimeInterval(_ virtualTimeInterval: Self.VirtualTimeIntervalUnit) -> Foundation.TimeInterval
  func convertToVirtualTimeInterval(_ timeInterval: Foundation.TimeInterval) -> Self.VirtualTimeIntervalUnit
  func offsetVirtualTime(_ time: Self.VirtualTimeUnit, offset: Self.VirtualTimeIntervalUnit) -> Self.VirtualTimeUnit
  func compareVirtualTime(_ lhs: Self.VirtualTimeUnit, _ rhs: Self.VirtualTimeUnit) -> AliIotConnectKit.VirtualTimeComparison
}
public enum VirtualTimeComparison {
  case lessThan
  case equal
  case greaterThan
  public static func == (a: AliIotConnectKit.VirtualTimeComparison, b: AliIotConnectKit.VirtualTimeComparison) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.ObservableType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) throws -> Key) -> AliIotConnectKit.Observable<Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) throws -> K, comparer: @escaping (K, K) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func concat<Source>(_ second: Source) -> AliIotConnectKit.Observable<Self.Element> where Source : AliIotConnectKit.ObservableConvertibleType, Self.Element == Source.Element
}
extension AliIotConnectKit.ObservableType {
  public static func concat<Sequence>(_ sequence: Sequence) -> AliIotConnectKit.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == AliIotConnectKit.Observable<Self.Element>
  public static func concat<Collection>(_ collection: Collection) -> AliIotConnectKit.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element == AliIotConnectKit.Observable<Self.Element>
  public static func concat(_ sources: AliIotConnectKit.Observable<Self.Element>...) -> AliIotConnectKit.Observable<Self.Element>
}
final public class OCB : AliIotConnectKit.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: AliIotConnectKit.OCB.Mode, b: AliIotConnectKit.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: AliIotConnectKit.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: AliIotConnectKit.OCB.Error, b: AliIotConnectKit.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: AliIotConnectKit.OCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: AliIotConnectKit.OCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public func startWith(_ elements: Self.Element...) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public static func amb<Sequence>(_ sequence: Sequence) -> AliIotConnectKit.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func amb<O2>(_ right: O2) -> AliIotConnectKit.Observable<Self.Element> where O2 : AliIotConnectKit.ObservableType, Self.Element == O2.Element
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
extension AliIotConnectKit.Disposables {
  public static func create(_ disposable1: any AliIotConnectKit.Disposable, _ disposable2: any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Cancelable
}
public protocol FilterType : AnyObject {
  func apply(_ value: Any) -> Swift.Bool
  func getTarget() -> AliIotConnectKit.Filter.TargetType
  func isRequired() -> Swift.Bool
  func isExcluded() -> Swift.Bool
  func reachedMinLevel(_ level: AliIotConnectKit.SwiftyBeaver.Level) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class Filters {
  public static let Path: AliIotConnectKit.PathFilterFactory.Type
  public static let Function: AliIotConnectKit.FunctionFilterFactory.Type
  public static let Message: AliIotConnectKit.MessageFilterFactory.Type
  @objc deinit
}
public class Filter {
  public enum TargetType {
    case Path(AliIotConnectKit.Filter.ComparisonType)
    case Function(AliIotConnectKit.Filter.ComparisonType)
    case Message(AliIotConnectKit.Filter.ComparisonType)
  }
  public enum ComparisonType {
    case StartsWith([Swift.String], Swift.Bool)
    case Contains([Swift.String], Swift.Bool)
    case Excludes([Swift.String], Swift.Bool)
    case EndsWith([Swift.String], Swift.Bool)
    case Equals([Swift.String], Swift.Bool)
    case Custom((Swift.String) -> Swift.Bool)
  }
  public init(_ target: AliIotConnectKit.Filter.TargetType, required: Swift.Bool, minLevel: AliIotConnectKit.SwiftyBeaver.Level)
  public func getTarget() -> AliIotConnectKit.Filter.TargetType
  public func isRequired() -> Swift.Bool
  public func isExcluded() -> Swift.Bool
  public func reachedMinLevel(_ level: AliIotConnectKit.SwiftyBeaver.Level) -> Swift.Bool
  @objc deinit
}
@_inheritsConvenienceInitializers public class CompareFilter : AliIotConnectKit.Filter, AliIotConnectKit.FilterType {
  override public init(_ target: AliIotConnectKit.Filter.TargetType, required: Swift.Bool, minLevel: AliIotConnectKit.SwiftyBeaver.Level)
  public func apply(_ value: Any) -> Swift.Bool
  override public func isExcluded() -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FunctionFilterFactory {
  public static func startsWith(_ prefixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func contains(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func excludes(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func endsWith(_ suffixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func equals(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func custom(required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose, filterPredicate: @escaping (Swift.String) -> Swift.Bool) -> any AliIotConnectKit.FilterType
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MessageFilterFactory {
  public static func startsWith(_ prefixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func contains(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func excludes(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func endsWith(_ suffixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func equals(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func custom(required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose, filterPredicate: @escaping (Swift.String) -> Swift.Bool) -> any AliIotConnectKit.FilterType
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PathFilterFactory {
  public static func startsWith(_ prefixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func contains(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func excludes(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func endsWith(_ suffixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func equals(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose) -> any AliIotConnectKit.FilterType
  public static func custom(required: Swift.Bool = false, minLevel: AliIotConnectKit.SwiftyBeaver.Level = .verbose, filterPredicate: @escaping (Swift.String) -> Swift.Bool) -> any AliIotConnectKit.FilterType
  @objc deinit
}
extension AliIotConnectKit.Filter.TargetType : Swift.Equatable {
}
public func == (lhs: AliIotConnectKit.Filter.TargetType, rhs: AliIotConnectKit.Filter.TargetType) -> Swift.Bool
extension AliIotConnectKit.ObservableType {
  public static func of(_ elements: Self.Element..., scheduler: any AliIotConnectKit.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public static func from(_ array: [Self.Element], scheduler: any AliIotConnectKit.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> AliIotConnectKit.Observable<Self.Element>
  public static func from<Sequence>(_ sequence: Sequence, scheduler: any AliIotConnectKit.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> AliIotConnectKit.Observable<Self.Element> where Sequence : Swift.Sequence, Self.Element == Sequence.Element
}
extension AliIotConnectKit.ObservableType {
  public func enumerated() -> AliIotConnectKit.Observable<(index: Swift.Int, element: Self.Element)>
}
@_hasMissingDesignatedInitializers public class Descriptor {
  final public let descriptor: CoreBluetooth.CBDescriptor
  final public let characteristic: AliIotConnectKit.Characteristic
  public var uuid: CoreBluetooth.CBUUID {
    get
  }
  public var value: Any? {
    get
  }
  public func observeWrite() -> AliIotConnectKit.Observable<AliIotConnectKit.Descriptor>
  public func writeValue(_ data: Foundation.Data) -> AliIotConnectKit.Single<AliIotConnectKit.Descriptor>
  public func observeValueUpdate() -> AliIotConnectKit.Observable<AliIotConnectKit.Descriptor>
  public func readValue() -> AliIotConnectKit.Single<AliIotConnectKit.Descriptor>
  @objc deinit
}
extension AliIotConnectKit.Descriptor : Swift.Equatable {
}
public func == (lhs: AliIotConnectKit.Descriptor, rhs: AliIotConnectKit.Descriptor) -> Swift.Bool
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
public protocol ManagerType : AnyObject {
  associatedtype Manager
  var manager: Self.Manager { get }
  var state: AliIotConnectKit.BluetoothState { get }
  func observeState() -> AliIotConnectKit.Observable<AliIotConnectKit.BluetoothState>
  func observeStateWithInitialValue() -> AliIotConnectKit.Observable<AliIotConnectKit.BluetoothState>
}
extension AliIotConnectKit.ManagerType {
  public func ensure<T>(_ state: AliIotConnectKit.BluetoothState, observable: AliIotConnectKit.Observable<T>) -> AliIotConnectKit.Observable<T>
}
public protocol Logger {
  func log(_ message: @autoclosure () -> Swift.String, level: AliIotConnectKit.RxBluetoothKitLog.LogLevel, file: Swift.StaticString, function: Swift.StaticString, line: Swift.UInt)
  func log(_ message: @autoclosure () -> Swift.String, level: AliIotConnectKit.RxBluetoothKitLog.LogLevel, file: Swift.String, function: Swift.String, line: Swift.UInt)
  func setLogLevel(_ logLevel: AliIotConnectKit.RxBluetoothKitLog.LogLevel)
  func getLogLevel() -> AliIotConnectKit.RxBluetoothKitLog.LogLevel
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: AliIotConnectKit.CipherError, b: AliIotConnectKit.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension AliIotConnectKit.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: AliIotConnectKit.Blowfish.Error, b: AliIotConnectKit.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any AliIotConnectKit.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: AliIotConnectKit.Padding) throws
  @objc deinit
}
extension AliIotConnectKit.Blowfish : AliIotConnectKit.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public struct RelpyPack_C : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias OnWillRestorePeripheralManagerState = (AliIotConnectKit.PeripheralManagerRestoredState) -> Swift.Void
extension AliIotConnectKit.PeripheralManager {
  convenience public init(queue: Dispatch.DispatchQueue = .main, options: [Swift.String : Swift.AnyObject]? = nil, cbPeripheralManager: CoreBluetooth.CBPeripheralManager? = nil, onWillRestorePeripheralManagerState: AliIotConnectKit.OnWillRestorePeripheralManagerState? = nil)
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : AliIotConnectKit._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [AliIotConnectKit.Bit]
  public func bits() -> Swift.String
}
extension AliIotConnectKit.ObservableType {
  public static func empty() -> AliIotConnectKit.Observable<Self.Element>
}
@_hasMissingDesignatedInitializers open class SwiftyBeaver {
  public static let version: Swift.String
  public static let build: Swift.Int
  public enum Level : Swift.Int {
    case verbose
    case debug
    case info
    case warning
    case error
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public static var destinations: Swift.Set<AliIotConnectKit.BaseDestination> {
    get
  }
  @discardableResult
  open class func addDestination(_ destination: AliIotConnectKit.BaseDestination) -> Swift.Bool
  @discardableResult
  open class func removeDestination(_ destination: AliIotConnectKit.BaseDestination) -> Swift.Bool
  open class func removeAllDestinations()
  open class func countDestinations() -> Swift.Int
  open class func verbose(_ message: @autoclosure () -> Any, _ file: Swift.String = #file, _ function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func debug(_ message: @autoclosure () -> Any, _ file: Swift.String = #file, _ function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func info(_ message: @autoclosure () -> Any, _ file: Swift.String = #file, _ function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func warning(_ message: @autoclosure () -> Any, _ file: Swift.String = #file, _ function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func error(_ message: @autoclosure () -> Any, _ file: Swift.String = #file, _ function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  public class func custom(level: AliIotConnectKit.SwiftyBeaver.Level, message: @autoclosure () -> Any, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  public class func flush(secondTimeout: Swift.Int64) -> Swift.Bool
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public static func create(_ subscribe: @escaping (AliIotConnectKit.AnyObserver<Self.Element>) -> any AliIotConnectKit.Disposable) -> AliIotConnectKit.Observable<Self.Element>
}
public enum AliCludIotConnectionState : Swift.Int {
  case connected
  case disconnected
  case connecting
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public typealias RxAbstractInteger = Swift.FixedWidthInteger
extension AliIotConnectKit.ObservableType {
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)? = nil, afterNext: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func reduce<A, Result>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A, mapResult: @escaping (A) throws -> Result) -> AliIotConnectKit.Observable<Result>
  public func reduce<A>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A) -> AliIotConnectKit.Observable<A>
}
public class ConcurrentDispatchQueueScheduler : AliIotConnectKit.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  public init(queue: Dispatch.DispatchQueue, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  @available(iOS 8, macOS 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: AliIotConnectKit.RxTimeInterval, period: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any AliIotConnectKit.Disposable
  @objc deinit
}
@_inheritsConvenienceInitializers final public class PublishSubject<Element> : AliIotConnectKit.Observable<Element>, AliIotConnectKit.SubjectType, AliIotConnectKit.Cancelable, AliIotConnectKit.ObserverType {
  public typealias SubjectObserverType = AliIotConnectKit.PublishSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public func on(_ event: AliIotConnectKit.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any AliIotConnectKit.Disposable where Element == Observer.Element, Observer : AliIotConnectKit.ObserverType
  final public func asObserver() -> AliIotConnectKit.PublishSubject<Element>
  final public func dispose()
  public typealias Observer = AliIotConnectKit.PublishSubject<Element>
  @objc deinit
}
extension AliIotConnectKit.ScannedPeripheral : Swift.Equatable {
  public static func == (lhs: AliIotConnectKit.ScannedPeripheral, rhs: AliIotConnectKit.ScannedPeripheral) -> Swift.Bool
}
extension Foundation.Data {
  public func hexString(uppercase: Swift.Bool = true, separator: Swift.String = "") -> Swift.String
}
public protocol ConnectableObservableType : AliIotConnectKit.ObservableType {
  func connect() -> any AliIotConnectKit.Disposable
}
extension AliIotConnectKit.ObservableType {
  public static func deferred(_ observableFactory: @escaping () throws -> AliIotConnectKit.Observable<Self.Element>) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func subscribe(_ on: @escaping (AliIotConnectKit.Event<Self.Element>) -> Swift.Void) -> any AliIotConnectKit.Disposable
  public func subscribe(onNext: ((Self.Element) -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any AliIotConnectKit.Disposable
}
extension AliIotConnectKit.Hooks {
  public typealias DefaultErrorHandler = (_ subscriptionCallStack: [Swift.String], _ error: any Swift.Error) -> Swift.Void
  public typealias CustomCaptureSubscriptionCallstack = () -> [Swift.String]
  public static var defaultErrorHandler: AliIotConnectKit.Hooks.DefaultErrorHandler {
    get
    set
  }
  public static var customCaptureSubscriptionCallstack: AliIotConnectKit.Hooks.CustomCaptureSubscriptionCallstack {
    get
    set
  }
}
extension AliIotConnectKit.ObservableType {
  public func delay(_ dueTime: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
public protocol Cancelable : AliIotConnectKit.Disposable {
  var isDisposed: Swift.Bool { get }
}
@objc public protocol IotStateDelatege_C {
  @objc func onIotConnected()
  @objc func onIotConnectFailed()
  @objc func onIotDisconeted()
  @objc func onIotConnecting()
  @objc func onLog(log: Swift.String)
}
@available(*, renamed: "Digest")
public typealias Hash = AliIotConnectKit.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: AliIotConnectKit.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: AliIotConnectKit.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public struct CFB : AliIotConnectKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: AliIotConnectKit.CFB.Error, b: AliIotConnectKit.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: AliIotConnectKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: AliIotConnectKit.CFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
}
@_hasMissingDesignatedInitializers public class ScannedPeripheral {
  final public let peripheral: AliIotConnectKit.Peripheral
  final public let advertisementData: AliIotConnectKit.AdvertisementData
  final public let rssi: Foundation.NSNumber
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class RSA {
  public enum Error : Swift.Error {
    case noPrivateKey
    case invalidInverseNotCoprimes
    case unsupportedRSAVersion
    case invalidPrimes
    case noPrimes
    case unableToCalculateCoefficient
    case invalidSignatureLength
    case invalidMessageLengthForSigning
    case invalidMessageLengthForEncryption
    case invalidDecryption
    public static func == (a: AliIotConnectKit.RSA.Error, b: AliIotConnectKit.RSA.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let n: AliIotConnectKit.BigUInteger
  final public let e: AliIotConnectKit.BigUInteger
  final public let d: AliIotConnectKit.BigUInteger?
  final public let keySize: Swift.Int
  final public let keySizeBytes: Swift.Int
  public init(n: AliIotConnectKit.BigUInteger, e: AliIotConnectKit.BigUInteger, d: AliIotConnectKit.BigUInteger? = nil)
  convenience public init(n: Swift.Array<Swift.UInt8>, e: Swift.Array<Swift.UInt8>, d: Swift.Array<Swift.UInt8>? = nil)
  convenience public init(keySize: Swift.Int) throws
  @objc deinit
}
extension AliIotConnectKit.RSA {
  convenience public init(rawRepresentation raw: Foundation.Data) throws
}
extension AliIotConnectKit.RSA {
  final public func externalRepresentation() throws -> Foundation.Data
  final public func publicKeyExternalRepresentation() throws -> Foundation.Data
}
extension AliIotConnectKit.CS.BigUInt {
  public static func generatePrime(_ width: Swift.Int) -> AliIotConnectKit.BigUInteger
}
extension AliIotConnectKit.RSA : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : AliIotConnectKit.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, eme_pkcs1v15, emsa_pkcs1v15, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: AliIotConnectKit.Padding, b: AliIotConnectKit.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class Poly1305 : AliIotConnectKit.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: AliIotConnectKit.Poly1305.Error, b: AliIotConnectKit.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public func withLatestFrom<Source, ResultType>(_ second: Source, resultSelector: @escaping (Self.Element, Source.Element) throws -> ResultType) -> AliIotConnectKit.Observable<ResultType> where Source : AliIotConnectKit.ObservableConvertibleType
  public func withLatestFrom<Source>(_ second: Source) -> AliIotConnectKit.Observable<Source.Element> where Source : AliIotConnectKit.ObservableConvertibleType
}
extension AliIotConnectKit.ObservableType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public static func zip<Collection>(_ collection: Collection, resultSelector: @escaping ([Collection.Element.Element]) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element : AliIotConnectKit.ObservableType
  public static func zip<Collection>(_ collection: Collection) -> AliIotConnectKit.Observable<[Self.Element]> where Collection : Swift.Collection, Self.Element == Collection.Element.Element, Collection.Element : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.CS.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
}
extension AliIotConnectKit.CS.BigInt {
  public init()
  public init(_ integer: AliIotConnectKit.CS.BigUInt)
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
}
extension AliIotConnectKit.CS.BigUInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.UInt64)
  public typealias IntegerLiteralType = Swift.UInt64
}
extension AliIotConnectKit.CS.BigInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int64)
  public typealias IntegerLiteralType = Swift.Int64
}
extension AliIotConnectKit.ObservableType {
  public func skip(_ count: Swift.Int) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func skip(_ duration: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
@_inheritsConvenienceInitializers final public class CompositeDisposable : AliIotConnectKit.DisposeBase, AliIotConnectKit.Cancelable {
  public struct DisposeKey {
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  public init(_ disposable1: any AliIotConnectKit.Disposable, _ disposable2: any AliIotConnectKit.Disposable)
  public init(_ disposable1: any AliIotConnectKit.Disposable, _ disposable2: any AliIotConnectKit.Disposable, _ disposable3: any AliIotConnectKit.Disposable)
  public init(_ disposable1: any AliIotConnectKit.Disposable, _ disposable2: any AliIotConnectKit.Disposable, _ disposable3: any AliIotConnectKit.Disposable, _ disposable4: any AliIotConnectKit.Disposable, _ disposables: any AliIotConnectKit.Disposable...)
  public init(disposables: [any AliIotConnectKit.Disposable])
  final public func insert(_ disposable: any AliIotConnectKit.Disposable) -> AliIotConnectKit.CompositeDisposable.DisposeKey?
  final public var count: Swift.Int {
    get
  }
  final public func remove(for disposeKey: AliIotConnectKit.CompositeDisposable.DisposeKey)
  final public func dispose()
  @objc deinit
}
extension AliIotConnectKit.Disposables {
  public static func create(_ disposable1: any AliIotConnectKit.Disposable, _ disposable2: any AliIotConnectKit.Disposable, _ disposable3: any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Cancelable
  public static func create(_ disposable1: any AliIotConnectKit.Disposable, _ disposable2: any AliIotConnectKit.Disposable, _ disposable3: any AliIotConnectKit.Disposable, _ disposables: any AliIotConnectKit.Disposable...) -> any AliIotConnectKit.Cancelable
  public static func create(_ disposables: [any AliIotConnectKit.Disposable]) -> any AliIotConnectKit.Cancelable
}
public enum BluetoothError : Swift.Error {
  case destroyed
  case scanInProgress
  case advertisingInProgress
  case advertisingStartFailed(any Swift.Error)
  case bluetoothUnsupported
  case bluetoothUnauthorized
  case bluetoothPoweredOff
  case bluetoothInUnknownState
  case bluetoothResetting
  case peripheralIsAlreadyObservingConnection(AliIotConnectKit.Peripheral)
  @available(*, deprecated, renamed: "BluetoothError.peripheralIsAlreadyObservingConnection")
  case peripheralIsConnectingOrAlreadyConnected(AliIotConnectKit.Peripheral)
  case peripheralConnectionFailed(AliIotConnectKit.Peripheral, (any Swift.Error)?)
  case peripheralDisconnected(AliIotConnectKit.Peripheral, (any Swift.Error)?)
  case peripheralRSSIReadFailed(AliIotConnectKit.Peripheral, (any Swift.Error)?)
  case servicesDiscoveryFailed(AliIotConnectKit.Peripheral, (any Swift.Error)?)
  case includedServicesDiscoveryFailed(AliIotConnectKit.Peripheral, (any Swift.Error)?)
  case addingServiceFailed(CoreBluetooth.CBService, (any Swift.Error)?)
  case characteristicsDiscoveryFailed(AliIotConnectKit.Service, (any Swift.Error)?)
  case characteristicWriteFailed(AliIotConnectKit.Characteristic, (any Swift.Error)?)
  case characteristicReadFailed(AliIotConnectKit.Characteristic, (any Swift.Error)?)
  case characteristicNotifyChangeFailed(AliIotConnectKit.Characteristic, (any Swift.Error)?)
  case characteristicSetNotifyValueFailed(AliIotConnectKit.Characteristic, (any Swift.Error)?)
  case descriptorsDiscoveryFailed(AliIotConnectKit.Characteristic, (any Swift.Error)?)
  case descriptorWriteFailed(AliIotConnectKit.Descriptor, (any Swift.Error)?)
  case descriptorReadFailed(AliIotConnectKit.Descriptor, (any Swift.Error)?)
  case openingL2CAPChannelFailed(AliIotConnectKit.Peripheral, (any Swift.Error)?)
  case publishingL2CAPChannelFailed(CoreBluetooth.CBL2CAPPSM, (any Swift.Error)?)
  case unknownWriteType
}
extension AliIotConnectKit.BluetoothError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AliIotConnectKit.BluetoothError : Swift.Equatable {
}
public func == (lhs: AliIotConnectKit.BluetoothError, rhs: AliIotConnectKit.BluetoothError) -> Swift.Bool
public enum RxBluetoothKitLogger {
  public static var defaultLogger: any AliIotConnectKit.Logger
}
@objc public protocol BleNeedSendDataDelegate_C {
  @objc func sendBleData(data: Foundation.Data)
}
@_inheritsConvenienceInitializers final public class SerialDisposable : AliIotConnectKit.DisposeBase, AliIotConnectKit.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public var disposable: any AliIotConnectKit.Disposable {
    get
    set(newDisposable)
  }
  final public func dispose()
  @objc deinit
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
  @inlinable internal subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get {
    return indices.contains(index) ? self[index] : nil
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: AliIotConnectKit.SHA2.Variant) -> [Element]
  public func sha3(_ variant: AliIotConnectKit.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: any AliIotConnectKit.Cipher) throws -> [Element]
  public func decrypt(cipher: any AliIotConnectKit.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : AliIotConnectKit.Authenticator
}
@_hasMissingDesignatedInitializers public class SerialDispatchQueueScheduler : AliIotConnectKit.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  convenience public init(internalSerialQueueName: Swift.String, serialQueueConfiguration: ((Dispatch.DispatchQueue) -> Swift.Void)? = nil, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  convenience public init(queue: Dispatch.DispatchQueue, internalSerialQueueName: Swift.String, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  @available(iOS 8, macOS 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS, internalSerialQueueName: Swift.String = "rx.global_dispatch_queue.serial", leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: AliIotConnectKit.RxTimeInterval, period: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any AliIotConnectKit.Disposable
  @objc deinit
}
public struct PCBC : AliIotConnectKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: AliIotConnectKit.PCBC.Error, b: AliIotConnectKit.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: AliIotConnectKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
}
@_hasMissingDesignatedInitializers final public class BehaviorSubject<Element> : AliIotConnectKit.Observable<Element>, AliIotConnectKit.SubjectType, AliIotConnectKit.ObserverType, AliIotConnectKit.Cancelable {
  public typealias SubjectObserverType = AliIotConnectKit.BehaviorSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(value: Element)
  final public func value() throws -> Element
  final public func on(_ event: AliIotConnectKit.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any AliIotConnectKit.Disposable where Element == Observer.Element, Observer : AliIotConnectKit.ObserverType
  final public func asObserver() -> AliIotConnectKit.BehaviorSubject<Element>
  final public func dispose()
  public typealias Observer = AliIotConnectKit.BehaviorSubject<Element>
  @objc deinit
}
final public class SHA2 {
  @usableFromInline
  final internal let variant: AliIotConnectKit.SHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: AliIotConnectKit.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: AliIotConnectKit.SHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: AliIotConnectKit.SHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension AliIotConnectKit.SHA2 : AliIotConnectKit.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
extension AliIotConnectKit.ObservableType {
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func ignoreElements() -> AliIotConnectKit.Completable
}
@_hasMissingDesignatedInitializers public class RxBluetoothKitLog : AliIotConnectKit.ReactiveCompatible {
  public static func setLogLevel(_ logLevel: AliIotConnectKit.RxBluetoothKitLog.LogLevel)
  public static func getLogLevel() -> AliIotConnectKit.RxBluetoothKitLog.LogLevel
  public enum LogLevel : Swift.UInt8 {
    case none
    case verbose
    case debug
    case info
    case warning
    case error
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public typealias ReactiveBase = AliIotConnectKit.RxBluetoothKitLog
  @objc deinit
}
extension AliIotConnectKit.RxBluetoothKitLog.LogLevel : Swift.Comparable {
  public static func < (lhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel, rhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel) -> Swift.Bool
  public static func <= (lhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel, rhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel) -> Swift.Bool
  public static func > (lhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel, rhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel) -> Swift.Bool
  public static func >= (lhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel, rhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel) -> Swift.Bool
  public static func == (lhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel, rhs: AliIotConnectKit.RxBluetoothKitLog.LogLevel) -> Swift.Bool
}
extension AliIotConnectKit.Reactive where Base == AliIotConnectKit.RxBluetoothKitLog {
  public var log: AliIotConnectKit.Observable<Swift.String> {
    get
  }
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: AliIotConnectKit.SHA3.Variant, b: AliIotConnectKit.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: AliIotConnectKit.SHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension AliIotConnectKit.SHA3 : AliIotConnectKit.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
extension AliIotConnectKit.CS.BigUInt {
  public mutating func subtractReportingOverflow(_ b: AliIotConnectKit.CS.BigUInt, shiftedBy shift: Swift.Int = 0) -> Swift.Bool
  public func subtractingReportingOverflow(_ other: AliIotConnectKit.CS.BigUInt, shiftedBy shift: Swift.Int) -> (partialValue: AliIotConnectKit.CS.BigUInt, overflow: Swift.Bool)
  public func subtractingReportingOverflow(_ other: AliIotConnectKit.CS.BigUInt) -> (partialValue: AliIotConnectKit.CS.BigUInt, overflow: Swift.Bool)
  public mutating func subtract(_ other: AliIotConnectKit.CS.BigUInt, shiftedBy shift: Swift.Int = 0)
  public func subtracting(_ other: AliIotConnectKit.CS.BigUInt, shiftedBy shift: Swift.Int = 0) -> AliIotConnectKit.CS.BigUInt
  public mutating func decrement(shiftedBy shift: Swift.Int = 0)
  public static func - (a: AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigUInt
  public static func -= (a: inout AliIotConnectKit.CS.BigUInt, b: AliIotConnectKit.CS.BigUInt)
}
extension AliIotConnectKit.CS.BigInt {
  public mutating func negate()
  public static func - (a: AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt
  public static func -= (a: inout AliIotConnectKit.CS.BigInt, b: AliIotConnectKit.CS.BigInt)
}
@_hasMissingDesignatedInitializers public class Characteristic {
  final public let characteristic: CoreBluetooth.CBCharacteristic
  final public let service: AliIotConnectKit.Service
  public var value: Foundation.Data? {
    get
  }
  public var uuid: CoreBluetooth.CBUUID {
    get
  }
  public var isNotifying: Swift.Bool {
    get
  }
  public var properties: CoreBluetooth.CBCharacteristicProperties {
    get
  }
  public var descriptors: [AliIotConnectKit.Descriptor]? {
    get
  }
  public func discoverDescriptors() -> AliIotConnectKit.Single<[AliIotConnectKit.Descriptor]>
  public func observeWrite() -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func observeNotifyValue() -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func writeValue(_ data: Foundation.Data, type: CoreBluetooth.CBCharacteristicWriteType) -> AliIotConnectKit.Single<AliIotConnectKit.Characteristic>
  public func observeValueUpdate() -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func readValue() -> AliIotConnectKit.Single<AliIotConnectKit.Characteristic>
  public func observeValueUpdateAndSetNotification() -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  @objc deinit
}
extension AliIotConnectKit.Characteristic : Swift.Equatable {
}
public func == (lhs: AliIotConnectKit.Characteristic, rhs: AliIotConnectKit.Characteristic) -> Swift.Bool
public class SBPlatformDestination : AliIotConnectKit.BaseDestination {
  public var appID: Swift.String
  public var appSecret: Swift.String
  public var encryptionKey: Swift.String
  public var analyticsUserName: Swift.String
  public var analyticsUUID: Swift.String {
    get
  }
  public struct SendingPoints {
    public var verbose: Swift.Int
    public var debug: Swift.Int
    public var info: Swift.Int
    public var warning: Swift.Int
    public var error: Swift.Int
    public var threshold: Swift.Int
  }
  public var sendingPoints: AliIotConnectKit.SBPlatformDestination.SendingPoints
  public var showNSLog: Swift.Bool
  public var serverURL: Foundation.URL?
  public var entriesFileURL: Foundation.URL
  public var sendingFileURL: Foundation.URL
  public var analyticsFileURL: Foundation.URL
  override public var defaultHashValue: Swift.Int {
    get
  }
  public init(appID: Swift.String, appSecret: Swift.String, encryptionKey: Swift.String, serverURL: Foundation.URL? = URL(string: "https://api.swiftybeaver.com/api/entries/"), entriesFileName: Swift.String = "sbplatform_entries.json", sendingfileName: Swift.String = "sbplatform_entries_sending.json", analyticsFileName: Swift.String = "sbplatform_analytics.json")
  override public func send(_ level: AliIotConnectKit.SwiftyBeaver.Level, msg: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, context: Any? = nil) -> Swift.String?
  public func sendNow()
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public func catchError(_ handler: @escaping (any Swift.Error) throws -> AliIotConnectKit.Observable<Self.Element>) -> AliIotConnectKit.Observable<Self.Element>
  public func catchErrorJustReturn(_ element: Self.Element) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public static func catchError<Sequence>(_ sequence: Sequence) -> AliIotConnectKit.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func retry() -> AliIotConnectKit.Observable<Self.Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> AliIotConnectKit.Observable<Self.Element>
}
public struct WearCommonEvent_C : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class PeripheralManager : AliIotConnectKit.ManagerType {
  final public let manager: CoreBluetooth.CBPeripheralManager
  convenience public init(queue: Dispatch.DispatchQueue = .main, options: [Swift.String : Swift.AnyObject]? = nil, cbPeripheralManager: CoreBluetooth.CBPeripheralManager? = nil)
  public var state: AliIotConnectKit.BluetoothState {
    get
  }
  public func observeState() -> AliIotConnectKit.Observable<AliIotConnectKit.BluetoothState>
  public func observeStateWithInitialValue() -> AliIotConnectKit.Observable<AliIotConnectKit.BluetoothState>
  public func startAdvertising(_ advertisementData: [Swift.String : Any]?) -> AliIotConnectKit.Observable<AliIotConnectKit.StartAdvertisingResult>
  public func add(_ service: CoreBluetooth.CBMutableService) -> AliIotConnectKit.Single<CoreBluetooth.CBService>
  public func remove(_ service: CoreBluetooth.CBMutableService)
  public func removeAllServices()
  public func observeDidReceiveRead() -> AliIotConnectKit.Observable<CoreBluetooth.CBATTRequest>
  public func observeDidReceiveWrite() -> AliIotConnectKit.Observable<[CoreBluetooth.CBATTRequest]>
  public func respond(to request: CoreBluetooth.CBATTRequest, withResult result: CoreBluetooth.CBATTError.Code)
  public func updateValue(_ value: Foundation.Data, for characteristic: CoreBluetooth.CBMutableCharacteristic, onSubscribedCentrals centrals: [CoreBluetooth.CBCentral]?) -> Swift.Bool
  public func observeIsReadyToUpdateSubscribers() -> AliIotConnectKit.Observable<Swift.Void>
  public func observeOnSubscribe() -> AliIotConnectKit.Observable<(CoreBluetooth.CBCentral, CoreBluetooth.CBCharacteristic)>
  public func observeOnUnsubscribe() -> AliIotConnectKit.Observable<(CoreBluetooth.CBCentral, CoreBluetooth.CBCharacteristic)>
  @available(iOS 11, tvOS 11, watchOS 4, *)
  public func publishL2CAPChannel(withEncryption encryptionRequired: Swift.Bool) -> AliIotConnectKit.Observable<CoreBluetooth.CBL2CAPPSM>
  @available(iOS 11, tvOS 11, watchOS 4, *)
  public func observeDidOpenL2CAPChannel() -> AliIotConnectKit.Observable<(CoreBluetooth.CBL2CAPChannel?, (any Swift.Error)?)>
  public typealias Manager = CoreBluetooth.CBPeripheralManager
  @objc deinit
}
public enum MaybeTrait {
}
public typealias Maybe<Element> = AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.MaybeTrait, Element>
public enum MaybeEvent<Element> {
  case success(Element)
  case error(any Swift.Error)
  case completed
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public typealias MaybeObserver = (AliIotConnectKit.MaybeEvent<Self.Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.MaybeObserver) -> any AliIotConnectKit.Disposable) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
  public func subscribe(_ observer: @escaping (AliIotConnectKit.MaybeEvent<Self.Element>) -> Swift.Void) -> any AliIotConnectKit.Disposable
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil) -> any AliIotConnectKit.Disposable
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public static func just(_ element: Self.Element) -> AliIotConnectKit.Maybe<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.Maybe<Self.Element>
  public static func error(_ error: any Swift.Error) -> AliIotConnectKit.Maybe<Self.Element>
  public static func never() -> AliIotConnectKit.Maybe<Self.Element>
  public static func empty() -> AliIotConnectKit.Maybe<Self.Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.MaybeTrait {
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)? = nil, afterNext: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> AliIotConnectKit.Maybe<Self.Element>
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> AliIotConnectKit.Maybe<Self.Element>
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> AliIotConnectKit.Maybe<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> AliIotConnectKit.Maybe<Result>
  public func flatMap<Result>(_ selector: @escaping (Self.Element) throws -> AliIotConnectKit.Maybe<Result>) -> AliIotConnectKit.Maybe<Result>
  public func ifEmpty(default: Self.Element) -> AliIotConnectKit.Single<Self.Element>
  public func ifEmpty(switchTo other: AliIotConnectKit.Maybe<Self.Element>) -> AliIotConnectKit.Maybe<Self.Element>
  public func ifEmpty(switchTo other: AliIotConnectKit.Single<Self.Element>) -> AliIotConnectKit.Single<Self.Element>
  public func catchErrorJustReturn(_ element: Self.Element) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
final public class BooleanDisposable : AliIotConnectKit.Cancelable {
  public init()
  public init(isDisposed: Swift.Bool)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
  @objc deinit
}
extension AliIotConnectKit.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: AliIotConnectKit.Padding = .pkcs7) throws
}
extension AliIotConnectKit.Observable {
  @available(*, deprecated, renamed: "from(optional:)", message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.")
  public static func from(_ optional: Element?) -> AliIotConnectKit.Observable<Element>
  @available(*, deprecated, renamed: "from(optional:scheduler:)", message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.")
  public static func from(_ optional: Element?, scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.Observable<Element>
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, message: "Please use enumerated().map()")
  public func mapWithIndex<Result>(_ selector: @escaping (Self.Element, Swift.Int) throws -> Result) -> AliIotConnectKit.Observable<Result>
  @available(*, deprecated, message: "Please use enumerated().flatMap()")
  public func flatMapWithIndex<Source>(_ selector: @escaping (Self.Element, Swift.Int) throws -> Source) -> AliIotConnectKit.Observable<Source.Element> where Source : AliIotConnectKit.ObservableConvertibleType
  @available(*, deprecated, message: "Please use enumerated().skipWhile().map()")
  public func skipWhileWithIndex(_ predicate: @escaping (Self.Element, Swift.Int) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
  @available(*, deprecated, message: "Please use enumerated().takeWhile().map()")
  public func takeWhileWithIndex(_ predicate: @escaping (Self.Element, Swift.Int) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.Disposable {
  @available(*, deprecated, renamed: "disposed(by:)", message: "use disposed(by:) instead")
  public func addDisposableTo(_ bag: AliIotConnectKit.DisposeBag)
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "share(replay:)", message: "use share(replay: 1) instead")
  public func shareReplayLatestWhileConnected() -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "share(replay:)", message: "Suggested replacement is `share(replay: 1)`. In case old 3.x behavior of `shareReplay` is required please use `share(replay: 1, scope: .forever)` instead.")
  public func shareReplay(_ bufferSize: Swift.Int) -> AliIotConnectKit.Observable<Self.Element>
}
@available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
final public class Variable<Element> {
  final public var value: Element {
    get
    set(newValue)
  }
  public init(_ value: Element)
  final public func asObservable() -> AliIotConnectKit.Observable<Element>
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "delay(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func delay(_ dueTime: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "timeout(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func timeout(_ dueTime: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
  @available(*, deprecated, renamed: "timeout(_:other:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func timeout<OtherSource>(_ dueTime: Foundation.TimeInterval, other: OtherSource, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element> where OtherSource : AliIotConnectKit.ObservableConvertibleType, Self.Element == OtherSource.Element
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "skip(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func skip(_ duration: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType where Self.Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "interval(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public static func interval(_ period: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType where Self.Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "timer(_:period:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public static func timer(_ dueTime: Foundation.TimeInterval, period: Foundation.TimeInterval? = nil, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "throttle(_:latest:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func throttle(_ dueTime: Foundation.TimeInterval, latest: Swift.Bool = true, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "take(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func take(_ duration: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "delaySubscription(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func delaySubscription(_ dueTime: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "window(_:)", message: "Use DispatchTimeInterval overload instead.")
  public func window(timeSpan: Foundation.TimeInterval, count: Swift.Int, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<AliIotConnectKit.Observable<Self.Element>>
}
extension AliIotConnectKit.PrimitiveSequence {
  @available(*, deprecated, renamed: "delay(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func delay(_ dueTime: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "delaySubscription(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func delaySubscription(_ dueTime: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "timeout(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func timeout(_ dueTime: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "timeout(_:other:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func timeout(_ dueTime: Foundation.TimeInterval, other: AliIotConnectKit.PrimitiveSequence<Trait, Element>, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Trait == AliIotConnectKit.SingleTrait {
  @available(*, deprecated, renamed: "do(onSuccess:onError:onSubscribe:onSubscribed:onDispose:)")
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)?, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> AliIotConnectKit.Single<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  @available(*, deprecated, renamed: "buffer(timeSpan:count:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public func buffer(timeSpan: Foundation.TimeInterval, count: Swift.Int, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<[Self.Element]>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "timer(_:scheduler:)", message: "Use DispatchTimeInterval overload instead.")
  public static func timer(_ dueTime: Foundation.TimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
extension AliIotConnectKit.PrimitiveSequence where Trait == AliIotConnectKit.CompletableTrait, Element == Swift.Never {
  @available(*, deprecated, renamed: "zip", message: "Use Completable.zip instead.")
  public static func merge<Collection>(_ sources: Collection) -> AliIotConnectKit.Completable where Collection : Swift.Collection, Collection.Element == AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.CompletableTrait, Swift.Never>
  @available(*, deprecated, renamed: "zip", message: "Use Completable.zip instead.")
  public static func merge(_ sources: [AliIotConnectKit.Completable]) -> AliIotConnectKit.Completable
  @available(*, deprecated, renamed: "zip", message: "Use Completable.zip instead.")
  public static func merge(_ sources: AliIotConnectKit.Completable...) -> AliIotConnectKit.Completable
}
open class BaseDestination : Swift.Hashable, Swift.Equatable {
  open var format: Swift.String
  open var asynchronously: Swift.Bool
  open var minLevel: AliIotConnectKit.SwiftyBeaver.Level
  open var levelString: AliIotConnectKit.BaseDestination.LevelString
  open var levelColor: AliIotConnectKit.BaseDestination.LevelColor
  public struct LevelString {
    public var verbose: Swift.String
    public var debug: Swift.String
    public var info: Swift.String
    public var warning: Swift.String
    public var error: Swift.String
  }
  public struct LevelColor {
    public var verbose: Swift.String
    public var debug: Swift.String
    public var info: Swift.String
    public var warning: Swift.String
    public var error: Swift.String
  }
  public func hash(into hasher: inout Swift.Hasher)
  open var defaultHashValue: Swift.Int {
    get
  }
  public init()
  open func send(_ level: AliIotConnectKit.SwiftyBeaver.Level, msg: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, context: Any? = nil) -> Swift.String?
  public func execute(synchronously: Swift.Bool, block: @escaping () -> Swift.Void)
  public func executeSynchronously<T>(block: @escaping () throws -> T) rethrows -> T
  public func addFilter(_ filter: any AliIotConnectKit.FilterType)
  public func removeFilter(_ filter: any AliIotConnectKit.FilterType)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
public func == (lhs: AliIotConnectKit.BaseDestination, rhs: AliIotConnectKit.BaseDestination) -> Swift.Bool
public struct PrimitiveSequence<Trait, Element> {
}
public protocol PrimitiveSequenceType {
  associatedtype Trait
  associatedtype Element
  @available(*, deprecated, renamed: "Trait")
  typealias TraitType = Self.Trait
  @available(*, deprecated, renamed: "Element")
  typealias ElementType = Self.Element
  var primitiveSequence: AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element> { get }
}
extension AliIotConnectKit.PrimitiveSequence : AliIotConnectKit.PrimitiveSequenceType {
  public var primitiveSequence: AliIotConnectKit.PrimitiveSequence<Trait, Element> {
    get
  }
}
extension AliIotConnectKit.PrimitiveSequence : AliIotConnectKit.ObservableConvertibleType {
  public func asObservable() -> AliIotConnectKit.Observable<Element>
}
extension AliIotConnectKit.PrimitiveSequence {
  public static func deferred(_ observableFactory: @escaping () throws -> AliIotConnectKit.PrimitiveSequence<Trait, Element>) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public func delay(_ dueTime: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public func delaySubscription(_ dueTime: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public func observeOn(_ scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public func subscribeOn(_ scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public func catchError(_ handler: @escaping (any Swift.Error) throws -> AliIotConnectKit.PrimitiveSequence<Trait, Element>) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (AliIotConnectKit.Observable<Error>) -> TriggerObservable) -> AliIotConnectKit.PrimitiveSequence<Trait, Element> where TriggerObservable : AliIotConnectKit.ObservableType, Error : Swift.Error
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (AliIotConnectKit.Observable<any Swift.Error>) -> TriggerObservable) -> AliIotConnectKit.PrimitiveSequence<Trait, Element> where TriggerObservable : AliIotConnectKit.ObservableType
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, primitiveSequenceFactory: @escaping (Resource) throws -> AliIotConnectKit.PrimitiveSequence<Trait, Element>) -> AliIotConnectKit.PrimitiveSequence<Trait, Element> where Resource : AliIotConnectKit.Disposable
  public func timeout(_ dueTime: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
  public func timeout(_ dueTime: AliIotConnectKit.RxTimeInterval, other: AliIotConnectKit.PrimitiveSequence<Trait, Element>, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Trait, Element>
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
}
public enum CompletableTrait {
}
public typealias Completable = AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.CompletableTrait, Swift.Never>
public enum CompletableEvent {
  case error(any Swift.Error)
  case completed
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == AliIotConnectKit.CompletableTrait {
  public typealias CompletableObserver = (AliIotConnectKit.CompletableEvent) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.CompletableObserver) -> any AliIotConnectKit.Disposable) -> AliIotConnectKit.PrimitiveSequence<Self.Trait, Self.Element>
  public func subscribe(_ observer: @escaping (AliIotConnectKit.CompletableEvent) -> Swift.Void) -> any AliIotConnectKit.Disposable
  public func subscribe(onCompleted: (() -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil) -> any AliIotConnectKit.Disposable
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == AliIotConnectKit.CompletableTrait {
  public static func error(_ error: any Swift.Error) -> AliIotConnectKit.Completable
  public static func never() -> AliIotConnectKit.Completable
  public static func empty() -> AliIotConnectKit.Completable
}
extension AliIotConnectKit.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == AliIotConnectKit.CompletableTrait {
  public func `do`(onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> AliIotConnectKit.Completable
  public func concat(_ second: AliIotConnectKit.Completable) -> AliIotConnectKit.Completable
  public static func concat<Sequence>(_ sequence: Sequence) -> AliIotConnectKit.Completable where Sequence : Swift.Sequence, Sequence.Element == AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.CompletableTrait, Swift.Never>
  public static func concat<Collection>(_ collection: Collection) -> AliIotConnectKit.Completable where Collection : Swift.Collection, Collection.Element == AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.CompletableTrait, Swift.Never>
  public static func concat(_ sources: AliIotConnectKit.Completable...) -> AliIotConnectKit.Completable
  public static func zip<Collection>(_ sources: Collection) -> AliIotConnectKit.Completable where Collection : Swift.Collection, Collection.Element == AliIotConnectKit.PrimitiveSequence<AliIotConnectKit.CompletableTrait, Swift.Never>
  public static func zip(_ sources: [AliIotConnectKit.Completable]) -> AliIotConnectKit.Completable
  public static func zip(_ sources: AliIotConnectKit.Completable...) -> AliIotConnectKit.Completable
}
extension AliIotConnectKit.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: AliIotConnectKit.PKCS5.PBKDF2.Error, b: AliIotConnectKit.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: AliIotConnectKit.HMAC.Variant = .sha2(.sha256)) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
    public func callAsFunction() throws -> Swift.Array<Swift.UInt8>
  }
}
final public class SHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  final public func callAsFunction(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension AliIotConnectKit.SHA1 : AliIotConnectKit.Updatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: SHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: SHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= SHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: SHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = SHA1.hashInitialValue
    }

    return result
  }
}
public protocol CipherModeWorker {
  var cipherOperation: AliIotConnectKit.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : AliIotConnectKit.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : AliIotConnectKit.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : AliIotConnectKit.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : AliIotConnectKit.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : AliIotConnectKit.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : AliIotConnectKit.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
extension AliIotConnectKit.CS {
  public struct BigUInt : Swift.UnsignedInteger {
    public typealias Word = Swift.UInt
    public init()
    public init(words: [AliIotConnectKit.CS.BigUInt.Word])
    public typealias Magnitude = AliIotConnectKit.CS.BigUInt
  }
}
extension AliIotConnectKit.CS.BigUInt {
  public static var isSigned: Swift.Bool {
    get
  }
  public func signum() -> AliIotConnectKit.CS.BigUInt
}
extension AliIotConnectKit.ObservableType {
  public func buffer(timeSpan: AliIotConnectKit.RxTimeInterval, count: Swift.Int, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<[Self.Element]>
}
extension AliIotConnectKit.CS.BigUInt : Swift.Strideable {
  public typealias Stride = AliIotConnectKit.CS.BigInt
  public func advanced(by n: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigUInt
  public func distance(to other: AliIotConnectKit.CS.BigUInt) -> AliIotConnectKit.CS.BigInt
}
extension AliIotConnectKit.CS.BigInt : Swift.Strideable {
  public typealias Stride = AliIotConnectKit.CS.BigInt
  public func advanced(by n: AliIotConnectKit.CS.BigInt.Stride) -> AliIotConnectKit.CS.BigInt
  public func distance(to other: AliIotConnectKit.CS.BigInt) -> AliIotConnectKit.CS.BigInt.Stride
}
extension AliIotConnectKit.RSA : AliIotConnectKit.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    return try self.encrypt(Array<UInt8>(bytes), variant: .pksc1v15)
  }
  @inlinable final public func encrypt(_ bytes: Swift.Array<Swift.UInt8>, variant: AliIotConnectKit.RSA.RSAEncryptionVariant) throws -> Swift.Array<Swift.UInt8> {
    // Prepare the data for the specified variant
    let preparedData = try variant.prepare(bytes, blockSize: self.keySizeBytes)

    // Encrypt the prepared data
    return try variant.formatEncryptedBytes(self.encryptPreparedBytes(preparedData), blockSize: self.keySizeBytes)
  }
  @inlinable final internal func encryptPreparedBytes(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    // Calculate encrypted data
    return BigUInteger(Data(bytes)).power(self.e, modulus: self.n).serialize().bytes
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    return try self.decrypt(Array<UInt8>(bytes), variant: .pksc1v15)
  }
  @inlinable final public func decrypt(_ bytes: Swift.Array<Swift.UInt8>, variant: AliIotConnectKit.RSA.RSAEncryptionVariant) throws -> Swift.Array<Swift.UInt8> {
    // Decrypt the data
    let decrypted = try self.decryptPreparedBytes(bytes)

    // Remove padding / unstructure data and return the raw plaintext
    return variant.removePadding(decrypted, blockSize: self.keySizeBytes)
  }
  @inlinable final internal func decryptPreparedBytes(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    // Check for Private Exponent presence
    guard let d = d else { throw RSA.Error.noPrivateKey }

    // Calculate decrypted data
    return BigUInteger(Data(bytes)).power(d, modulus: self.n).serialize().bytes
  }
}
extension AliIotConnectKit.RSA {
  @frozen public enum RSAEncryptionVariant {
    case unsafe
    case raw
    case pksc1v15
    @inlinable internal func prepare(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) throws -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw:
          // We need at least 11 bytes of padding in order to safely encrypt messages
          // - block types 1 and 2 have this minimum padding requirement, block type 0 isn't specified, but we enforce the minimum padding length here to be safe.
          guard blockSize >= bytes.count + 11 else { throw RSA.Error.invalidMessageLengthForEncryption }
          return Array(repeating: 0x00, count: blockSize - bytes.count) + bytes
        case .pksc1v15:
          // The `Security` framework refuses to encrypt a zero byte message using the pkcs1v15 padding scheme, so we do the same
          guard !bytes.isEmpty else { throw RSA.Error.invalidMessageLengthForEncryption }
          // We need at least 11 bytes of random padding in order to safely encrypt messages (RFC2313 Section 8.1 - Note 6)
          guard blockSize >= bytes.count + 11 else { throw RSA.Error.invalidMessageLengthForEncryption }
          return Padding.eme_pkcs1v15.add(to: bytes, blockSize: blockSize)
      }
    }
    @inlinable internal func formatEncryptedBytes(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw, .pksc1v15:
          // Format the encrypted bytes before returning
          return Array<UInt8>(repeating: 0x00, count: blockSize - bytes.count) + bytes
      }
    }
    @inlinable internal func removePadding(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw:
          return bytes
        case .pksc1v15:
          // Convert the Octet String into an Integer Primitive using the BigInteger `serialize` method
          // (this effectively just prefixes the data with a 0x00 byte indicating that its a positive integer)
          return Padding.eme_pkcs1v15.remove(from: [0x00] + bytes, blockSize: blockSize)
      }
    }
    public static func == (a: AliIotConnectKit.RSA.RSAEncryptionVariant, b: AliIotConnectKit.RSA.RSAEncryptionVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
open class VirtualTimeScheduler<Converter> : AliIotConnectKit.SchedulerType where Converter : AliIotConnectKit.VirtualTimeConverterType {
  public typealias VirtualTime = Converter.VirtualTimeUnit
  public typealias VirtualTimeInterval = Converter.VirtualTimeIntervalUnit
  public var now: AliIotConnectKit.RxTime {
    get
  }
  public var clock: AliIotConnectKit.VirtualTimeScheduler<Converter>.VirtualTime {
    get
  }
  public init(initialClock: AliIotConnectKit.VirtualTimeScheduler<Converter>.VirtualTime, converter: Converter)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  public func scheduleRelative<StateType>(_ state: StateType, dueTime: AliIotConnectKit.RxTimeInterval, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  public func scheduleRelativeVirtual<StateType>(_ state: StateType, dueTime: AliIotConnectKit.VirtualTimeScheduler<Converter>.VirtualTimeInterval, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  public func scheduleAbsoluteVirtual<StateType>(_ state: StateType, time: AliIotConnectKit.VirtualTimeScheduler<Converter>.VirtualTime, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  open func adjustScheduledTime(_ time: AliIotConnectKit.VirtualTimeScheduler<Converter>.VirtualTime) -> AliIotConnectKit.VirtualTimeScheduler<Converter>.VirtualTime
  public func start()
  public func advanceTo(_ virtualTime: AliIotConnectKit.VirtualTimeScheduler<Converter>.VirtualTime)
  public func sleep(_ virtualInterval: AliIotConnectKit.VirtualTimeScheduler<Converter>.VirtualTimeInterval)
  public func stop()
  @objc deinit
}
extension AliIotConnectKit.VirtualTimeScheduler : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AliIotConnectKit.CS.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension AliIotConnectKit.CS.BigInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension Swift.BinaryFloatingPoint where Self.RawExponent : Swift.FixedWidthInteger, Self.RawSignificand : Swift.FixedWidthInteger {
  public init(_ value: AliIotConnectKit.CS.BigInt)
  public init(_ value: AliIotConnectKit.CS.BigUInt)
}
extension AliIotConnectKit.ObservableType {
  public func asSingle() -> AliIotConnectKit.Single<Self.Element>
  public func first() -> AliIotConnectKit.Single<Self.Element?>
  public func asMaybe() -> AliIotConnectKit.Maybe<Self.Element>
}
extension AliIotConnectKit.ObservableType where Self.Element == Swift.Never {
  public func asCompletable() -> AliIotConnectKit.Completable
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: AliIotConnectKit.Rabbit.Error, b: AliIotConnectKit.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension AliIotConnectKit.Rabbit : AliIotConnectKit.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public enum PKCS7 {
}
public struct ECB : AliIotConnectKit.BlockMode {
  public let options: AliIotConnectKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
}
extension AliIotConnectKit.AES : AliIotConnectKit.Cryptors {
  @inlinable final public func makeEncryptor() throws -> any AliIotConnectKit.Cryptor & AliIotConnectKit.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> any AliIotConnectKit.Cryptor & AliIotConnectKit.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
extension AliIotConnectKit.ObservableType {
  public func observeOn(_ scheduler: any AliIotConnectKit.ImmediateSchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func skipUntil<Source>(_ other: Source) -> AliIotConnectKit.Observable<Self.Element> where Source : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public func take(_ count: Swift.Int) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func take(_ duration: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers public class AliCloudIotLogManager_C : ObjectiveC.NSObject {
  @objc public static let shared: AliIotConnectKit.AliCloudIotLogManager_C
  @objc public func switchLogStatus(_ isOpen: Swift.Bool = true)
  @objc public func switchMQTTLogStatus(_ isOpen: Swift.Bool = true)
  @objc deinit
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension AliIotConnectKit.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: AliIotConnectKit.BatchedCollectionIndex<Base>, rhs: AliIotConnectKit.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: AliIotConnectKit.BatchedCollectionIndex<Base>, rhs: AliIotConnectKit.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = AliIotConnectKit.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: AliIotConnectKit.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: AliIotConnectKit.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: AliIotConnectKit.BatchedCollection<Base>.Index) -> AliIotConnectKit.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: AliIotConnectKit.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<AliIotConnectKit.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<AliIotConnectKit.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<AliIotConnectKit.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> AliIotConnectKit.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
extension AliIotConnectKit.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@_hasMissingDesignatedInitializers public class ThingCommunicateService_C {
  public func wearCommonEventUpload(event: AliIotConnectKit.WearCommonEvent_C) throws
  public func wearCommonCommandReply(replyPack: AliIotConnectKit.RelpyPack_C) throws
  public func tryResolve(topic: Swift.String, messageData: Any?) -> AliIotConnectKit.WearCommonCommand_C?
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public func debounce(_ dueTime: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  final public func callAsFunction() throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct AnyObserver<Element> : AliIotConnectKit.ObserverType {
  public typealias EventHandler = (AliIotConnectKit.Event<Element>) -> Swift.Void
  public init(eventHandler: @escaping AliIotConnectKit.AnyObserver<Element>.EventHandler)
  public init<Observer>(_ observer: Observer) where Element == Observer.Element, Observer : AliIotConnectKit.ObserverType
  public func on(_ event: AliIotConnectKit.Event<Element>)
  public func asObserver() -> AliIotConnectKit.AnyObserver<Element>
}
extension AliIotConnectKit.ObserverType {
  public func asObserver() -> AliIotConnectKit.AnyObserver<Self.Element>
  public func mapObserver<Result>(_ transform: @escaping (Result) throws -> Self.Element) -> AliIotConnectKit.AnyObserver<Result>
}
public protocol SubjectType : AliIotConnectKit.ObservableType {
  associatedtype Observer : AliIotConnectKit.ObserverType
  @available(*, deprecated, renamed: "Observer")
  typealias SubjectObserverType = Self.Observer
  func asObserver() -> Self.Observer
}
@_hasMissingDesignatedInitializers public class CurrentThreadScheduler : AliIotConnectKit.ImmediateSchedulerType {
  public static let instance: AliIotConnectKit.CurrentThreadScheduler
  public static var isScheduleRequired: Swift.Bool {
    get
  }
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> AliIotConnectKit.Observable<(O1.Element, O2.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType, O7 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType, O7 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Self.Element) -> AliIotConnectKit.Observable<Self.Element> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType, O7 : AliIotConnectKit.ObservableType, O8 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> AliIotConnectKit.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : AliIotConnectKit.ObservableType, O2 : AliIotConnectKit.ObservableType, O3 : AliIotConnectKit.ObservableType, O4 : AliIotConnectKit.ObservableType, O5 : AliIotConnectKit.ObservableType, O6 : AliIotConnectKit.ObservableType, O7 : AliIotConnectKit.ObservableType, O8 : AliIotConnectKit.ObservableType
}
extension AliIotConnectKit.CS.BigInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension AliIotConnectKit.CS.BigUInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension AliIotConnectKit.Peripheral {
  public func service(with identifier: any AliIotConnectKit.ServiceIdentifier) -> AliIotConnectKit.Single<AliIotConnectKit.Service>
  public func characteristic(with identifier: any AliIotConnectKit.CharacteristicIdentifier) -> AliIotConnectKit.Single<AliIotConnectKit.Characteristic>
  public func descriptor(with identifier: any AliIotConnectKit.DescriptorIdentifier) -> AliIotConnectKit.Single<AliIotConnectKit.Descriptor>
  public func observeWrite(for identifier: any AliIotConnectKit.CharacteristicIdentifier) -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func writeValue(_ data: Foundation.Data, for identifier: any AliIotConnectKit.CharacteristicIdentifier, type: CoreBluetooth.CBCharacteristicWriteType) -> AliIotConnectKit.Single<AliIotConnectKit.Characteristic>
  public func observeValueUpdate(for identifier: any AliIotConnectKit.CharacteristicIdentifier) -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func readValue(for identifier: any AliIotConnectKit.CharacteristicIdentifier) -> AliIotConnectKit.Single<AliIotConnectKit.Characteristic>
  public func observeValueUpdateAndSetNotification(for identifier: any AliIotConnectKit.CharacteristicIdentifier) -> AliIotConnectKit.Observable<AliIotConnectKit.Characteristic>
  public func discoverDescriptors(for identifier: any AliIotConnectKit.CharacteristicIdentifier) -> AliIotConnectKit.Single<[AliIotConnectKit.Descriptor]>
  public func observeWrite(for identifier: any AliIotConnectKit.DescriptorIdentifier) -> AliIotConnectKit.Observable<AliIotConnectKit.Descriptor>
  public func writeValue(_ data: Foundation.Data, for identifier: any AliIotConnectKit.DescriptorIdentifier) -> AliIotConnectKit.Single<AliIotConnectKit.Descriptor>
  public func observeValueUpdate(for identifier: any AliIotConnectKit.DescriptorIdentifier) -> AliIotConnectKit.Observable<AliIotConnectKit.Descriptor>
  public func readValue(for identifier: any AliIotConnectKit.DescriptorIdentifier) -> AliIotConnectKit.Single<AliIotConnectKit.Descriptor>
}
extension AliIotConnectKit.ObservableType {
  public func delaySubscription(_ dueTime: AliIotConnectKit.RxTimeInterval, scheduler: any AliIotConnectKit.SchedulerType) -> AliIotConnectKit.Observable<Self.Element>
}
public protocol ServiceIdentifier {
  var uuid: CoreBluetooth.CBUUID { get }
}
public protocol CharacteristicIdentifier {
  var uuid: CoreBluetooth.CBUUID { get }
  var service: any AliIotConnectKit.ServiceIdentifier { get }
}
public protocol DescriptorIdentifier {
  var uuid: CoreBluetooth.CBUUID { get }
  var characteristic: any AliIotConnectKit.CharacteristicIdentifier { get }
}
@_inheritsConvenienceInitializers final public class AsyncSubject<Element> : AliIotConnectKit.Observable<Element>, AliIotConnectKit.SubjectType, AliIotConnectKit.ObserverType {
  public typealias SubjectObserverType = AliIotConnectKit.AsyncSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  public init()
  final public func on(_ event: AliIotConnectKit.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any AliIotConnectKit.Disposable where Element == Observer.Element, Observer : AliIotConnectKit.ObserverType
  final public func asObserver() -> AliIotConnectKit.AsyncSubject<Element>
  public typealias Observer = AliIotConnectKit.AsyncSubject<Element>
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ConnectableObservable<Element> : AliIotConnectKit.Observable<Element>, AliIotConnectKit.ConnectableObservableType {
  public func connect() -> any AliIotConnectKit.Disposable
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public func multicast<Subject, Result>(_ subjectSelector: @escaping () throws -> Subject, selector: @escaping (AliIotConnectKit.Observable<Subject.Element>) throws -> AliIotConnectKit.Observable<Result>) -> AliIotConnectKit.Observable<Result> where Subject : AliIotConnectKit.SubjectType, Self.Element == Subject.Observer.Element
}
extension AliIotConnectKit.ObservableType {
  public func publish() -> AliIotConnectKit.ConnectableObservable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func replay(_ bufferSize: Swift.Int) -> AliIotConnectKit.ConnectableObservable<Self.Element>
  public func replayAll() -> AliIotConnectKit.ConnectableObservable<Self.Element>
}
extension AliIotConnectKit.ConnectableObservableType {
  public func refCount() -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func multicast<Subject>(_ subject: Subject) -> AliIotConnectKit.ConnectableObservable<Subject.Element> where Subject : AliIotConnectKit.SubjectType, Self.Element == Subject.Observer.Element
  public func multicast<Subject>(makeSubject: @escaping () -> Subject) -> AliIotConnectKit.ConnectableObservable<Subject.Element> where Subject : AliIotConnectKit.SubjectType, Self.Element == Subject.Observer.Element
}
extension AliIotConnectKit.CS {
  public struct BigInt : Swift.SignedInteger {
    public enum Sign {
      case plus
      case minus
      public static func == (a: AliIotConnectKit.CS.BigInt.Sign, b: AliIotConnectKit.CS.BigInt.Sign) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public typealias Magnitude = AliIotConnectKit.CS.BigUInt
    public typealias Word = AliIotConnectKit.CS.BigUInt.Word
    public static var isSigned: Swift.Bool {
      get
    }
    public var magnitude: AliIotConnectKit.CS.BigUInt
    public var sign: AliIotConnectKit.CS.BigInt.Sign
    public init(sign: AliIotConnectKit.CS.BigInt.Sign, magnitude: AliIotConnectKit.CS.BigUInt)
    public var isZero: Swift.Bool {
      get
    }
    public func signum() -> AliIotConnectKit.CS.BigInt
  }
}
@usableFromInline
final internal class StreamEncryptor : AliIotConnectKit.Cryptor, AliIotConnectKit.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any AliIotConnectKit.CipherModeWorker
  @usableFromInline
  final internal let padding: AliIotConnectKit.Padding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: AliIotConnectKit.Padding, _ worker: any AliIotConnectKit.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension AliIotConnectKit.ObservableType {
  public func skipWhile(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> AliIotConnectKit.Observable<Self.Element>
}
extension AliIotConnectKit.ObservableType {
  public func elementAt(_ index: Swift.Int) -> AliIotConnectKit.Observable<Self.Element>
}
public enum PKCS5 {
}
@_hasMissingDesignatedInitializers public class DisposeBase {
  @objc deinit
}
extension AliIotConnectKit.ObservableType {
  public static func repeatElement(_ element: Self.Element, scheduler: any AliIotConnectKit.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> AliIotConnectKit.Observable<Self.Element>
}
public typealias BigInteger = AliIotConnectKit.CS.BigInt
public typealias BigUInteger = AliIotConnectKit.CS.BigUInt
public enum CS {
}
final public class GCM : AliIotConnectKit.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: AliIotConnectKit.GCM.Mode, b: AliIotConnectKit.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: AliIotConnectKit.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: AliIotConnectKit.GCM.Error, b: AliIotConnectKit.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: AliIotConnectKit.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: AliIotConnectKit.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping AliIotConnectKit.CipherOperationOnBlock, encryptionOperation: @escaping AliIotConnectKit.CipherOperationOnBlock) throws -> any AliIotConnectKit.CipherModeWorker
  @objc deinit
}
public enum BluetoothState : Swift.Int {
  case unknown
  case resetting
  case unsupported
  case unauthorized
  case poweredOff
  case poweredOn
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.Disposables {
  public static func create(with dispose: @escaping () -> Swift.Void) -> any AliIotConnectKit.Cancelable
}
public class OperationQueueScheduler : AliIotConnectKit.ImmediateSchedulerType {
  final public let operationQueue: Foundation.OperationQueue
  final public let queuePriority: Foundation.Operation.QueuePriority
  public init(operationQueue: Foundation.OperationQueue, queuePriority: Foundation.Operation.QueuePriority = .normal)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any AliIotConnectKit.Disposable) -> any AliIotConnectKit.Disposable
  @objc deinit
}
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: AliIotConnectKit.JSON) throws
  public func merged(with other: AliIotConnectKit.JSON) throws -> AliIotConnectKit.JSON
  public var type: AliIotConnectKit.`Type` {
    get
  }
  public var error: AliIotConnectKit.SwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: AliIotConnectKit.JSON {
    get
  }
  public static var null: AliIotConnectKit.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: AliIotConnectKit.Index<T>, rhs: AliIotConnectKit.Index<T>) -> Swift.Bool
  public static func < (lhs: AliIotConnectKit.Index<T>, rhs: AliIotConnectKit.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = AliIotConnectKit.Index<AliIotConnectKit.JSON>
public typealias JSONRawIndex = AliIotConnectKit.Index<Any>
extension AliIotConnectKit.JSON : Swift.Collection {
  public typealias Index = AliIotConnectKit.JSONRawIndex
  public var startIndex: AliIotConnectKit.JSON.Index {
    get
  }
  public var endIndex: AliIotConnectKit.JSON.Index {
    get
  }
  public func index(after i: AliIotConnectKit.JSON.Index) -> AliIotConnectKit.JSON.Index
  public subscript(position: AliIotConnectKit.JSON.Index) -> (Swift.String, AliIotConnectKit.JSON) {
    get
  }
  public typealias Element = (Swift.String, AliIotConnectKit.JSON)
  public typealias Indices = Swift.DefaultIndices<AliIotConnectKit.JSON>
  public typealias Iterator = Swift.IndexingIterator<AliIotConnectKit.JSON>
  public typealias SubSequence = Swift.Slice<AliIotConnectKit.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: AliIotConnectKit.JSONKey { get }
}
extension Swift.Int : AliIotConnectKit.JSONSubscriptType {
  public var jsonKey: AliIotConnectKit.JSONKey {
    get
  }
}
extension Swift.String : AliIotConnectKit.JSONSubscriptType {
  public var jsonKey: AliIotConnectKit.JSONKey {
    get
  }
}
extension AliIotConnectKit.JSON {
  public subscript(path: [any AliIotConnectKit.JSONSubscriptType]) -> AliIotConnectKit.JSON {
    get
    set
  }
  public subscript(path: any AliIotConnectKit.JSONSubscriptType...) -> AliIotConnectKit.JSON {
    get
    set
  }
}
extension AliIotConnectKit.JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension AliIotConnectKit.JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension AliIotConnectKit.JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension AliIotConnectKit.JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension AliIotConnectKit.JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension AliIotConnectKit.JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension AliIotConnectKit.JSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [AliIotConnectKit.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension AliIotConnectKit.JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension AliIotConnectKit.JSON {
  public var array: [AliIotConnectKit.JSON]? {
    get
  }
  public var arrayValue: [AliIotConnectKit.JSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension AliIotConnectKit.JSON {
  public var dictionary: [Swift.String : AliIotConnectKit.JSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : AliIotConnectKit.JSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension AliIotConnectKit.JSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension AliIotConnectKit.JSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension AliIotConnectKit.JSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension AliIotConnectKit.JSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension AliIotConnectKit.JSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension AliIotConnectKit.JSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension AliIotConnectKit.JSON : Swift.Comparable {
}
public func == (lhs: AliIotConnectKit.JSON, rhs: AliIotConnectKit.JSON) -> Swift.Bool
public func <= (lhs: AliIotConnectKit.JSON, rhs: AliIotConnectKit.JSON) -> Swift.Bool
public func >= (lhs: AliIotConnectKit.JSON, rhs: AliIotConnectKit.JSON) -> Swift.Bool
public func > (lhs: AliIotConnectKit.JSON, rhs: AliIotConnectKit.JSON) -> Swift.Bool
public func < (lhs: AliIotConnectKit.JSON, rhs: AliIotConnectKit.JSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: AliIotConnectKit.writingOptionsKeys, b: AliIotConnectKit.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AliIotConnectKit.JSON : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension AliIotConnectKit.CMAC.Error : Swift.Equatable {}
extension AliIotConnectKit.CMAC.Error : Swift.Hashable {}
extension AliIotConnectKit.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension AliIotConnectKit.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension AliIotConnectKit.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension AliIotConnectKit.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension AliIotConnectKit.SubjectLifetimeScope : Swift.Equatable {}
extension AliIotConnectKit.SubjectLifetimeScope : Swift.Hashable {}
extension AliIotConnectKit.AES.Error : Swift.Equatable {}
extension AliIotConnectKit.AES.Error : Swift.Hashable {}
extension AliIotConnectKit.AES.Variant : Swift.Equatable {}
extension AliIotConnectKit.AES.Variant : Swift.Hashable {}
extension AliIotConnectKit.AES.Variant : Swift.RawRepresentable {}
extension AliIotConnectKit.CBC.Error : Swift.Equatable {}
extension AliIotConnectKit.CBC.Error : Swift.Hashable {}
extension AliIotConnectKit.TakeUntilBehavior : Swift.Equatable {}
extension AliIotConnectKit.TakeUntilBehavior : Swift.Hashable {}
extension AliIotConnectKit.Bit : Swift.Equatable {}
extension AliIotConnectKit.Bit : Swift.Hashable {}
extension AliIotConnectKit.Bit : Swift.RawRepresentable {}
extension AliIotConnectKit.CTR : AliIotConnectKit.BlockMode {}
extension AliIotConnectKit.CTR.Error : Swift.Equatable {}
extension AliIotConnectKit.CTR.Error : Swift.Hashable {}
extension AliIotConnectKit.RSA.SignatureVariant : Swift.Equatable {}
extension AliIotConnectKit.RSA.SignatureVariant : Swift.Hashable {}
extension AliIotConnectKit.ChaCha20.Error : Swift.Equatable {}
extension AliIotConnectKit.ChaCha20.Error : Swift.Hashable {}
extension AliIotConnectKit.SwiftyBeaver.Level : Swift.Equatable {}
extension AliIotConnectKit.SwiftyBeaver.Level : Swift.Hashable {}
extension AliIotConnectKit.SwiftyBeaver.Level : Swift.RawRepresentable {}
extension AliIotConnectKit.HKDF.Error : Swift.Equatable {}
extension AliIotConnectKit.HKDF.Error : Swift.Hashable {}
extension AliIotConnectKit.HMAC.Error : Swift.Equatable {}
extension AliIotConnectKit.HMAC.Error : Swift.Hashable {}
extension AliIotConnectKit.CCM : AliIotConnectKit.BlockMode {}
extension AliIotConnectKit.CCM.Error : Swift.Equatable {}
extension AliIotConnectKit.CCM.Error : Swift.Hashable {}
extension AliIotConnectKit.OFB.Error : Swift.Equatable {}
extension AliIotConnectKit.OFB.Error : Swift.Hashable {}
extension AliIotConnectKit.SignatureError : Swift.Equatable {}
extension AliIotConnectKit.SignatureError : Swift.Hashable {}
extension AliIotConnectKit.VirtualTimeComparison : Swift.Equatable {}
extension AliIotConnectKit.VirtualTimeComparison : Swift.Hashable {}
extension AliIotConnectKit.OCB.Mode : Swift.Equatable {}
extension AliIotConnectKit.OCB.Mode : Swift.Hashable {}
extension AliIotConnectKit.OCB.Error : Swift.Equatable {}
extension AliIotConnectKit.OCB.Error : Swift.Hashable {}
extension AliIotConnectKit.CipherError : Swift.Equatable {}
extension AliIotConnectKit.CipherError : Swift.Hashable {}
extension AliIotConnectKit.Blowfish.Error : Swift.Equatable {}
extension AliIotConnectKit.Blowfish.Error : Swift.Hashable {}
extension AliIotConnectKit.AliCludIotConnectionState : Swift.Equatable {}
extension AliIotConnectKit.AliCludIotConnectionState : Swift.Hashable {}
extension AliIotConnectKit.AliCludIotConnectionState : Swift.RawRepresentable {}
extension AliIotConnectKit.CFB.Error : Swift.Equatable {}
extension AliIotConnectKit.CFB.Error : Swift.Hashable {}
extension AliIotConnectKit.CFB.SegmentSize : Swift.Equatable {}
extension AliIotConnectKit.CFB.SegmentSize : Swift.Hashable {}
extension AliIotConnectKit.CFB.SegmentSize : Swift.RawRepresentable {}
extension AliIotConnectKit.RSA.Error : Swift.Equatable {}
extension AliIotConnectKit.RSA.Error : Swift.Hashable {}
extension AliIotConnectKit.Padding : Swift.Equatable {}
extension AliIotConnectKit.Padding : Swift.Hashable {}
extension AliIotConnectKit.Poly1305.Error : Swift.Equatable {}
extension AliIotConnectKit.Poly1305.Error : Swift.Hashable {}
extension AliIotConnectKit.PCBC.Error : Swift.Equatable {}
extension AliIotConnectKit.PCBC.Error : Swift.Hashable {}
extension AliIotConnectKit.SHA2.Variant : Swift.Equatable {}
extension AliIotConnectKit.SHA2.Variant : Swift.Hashable {}
extension AliIotConnectKit.SHA2.Variant : Swift.Sendable {}
extension AliIotConnectKit.RxBluetoothKitLog.LogLevel : Swift.Hashable {}
extension AliIotConnectKit.RxBluetoothKitLog.LogLevel : Swift.RawRepresentable {}
extension AliIotConnectKit.BluetoothState : Swift.Equatable {}
extension AliIotConnectKit.BluetoothState : Swift.Hashable {}
extension AliIotConnectKit.BluetoothState : Swift.RawRepresentable {}
extension AliIotConnectKit.SHA3.Variant : Swift.Equatable {}
extension AliIotConnectKit.SHA3.Variant : Swift.Hashable {}
extension AliIotConnectKit.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension AliIotConnectKit.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension AliIotConnectKit.RSA.RSAEncryptionVariant : Swift.Equatable {}
extension AliIotConnectKit.RSA.RSAEncryptionVariant : Swift.Hashable {}
extension AliIotConnectKit.RSA.RSAEncryptionVariant : Swift.Sendable {}
extension AliIotConnectKit.Rabbit.Error : Swift.Equatable {}
extension AliIotConnectKit.Rabbit.Error : Swift.Hashable {}
extension AliIotConnectKit.CS.BigInt.Sign : Swift.Equatable {}
extension AliIotConnectKit.CS.BigInt.Sign : Swift.Hashable {}
extension AliIotConnectKit.GCM.Mode : Swift.Equatable {}
extension AliIotConnectKit.GCM.Mode : Swift.Hashable {}
extension AliIotConnectKit.GCM.Error : Swift.Equatable {}
extension AliIotConnectKit.GCM.Error : Swift.Hashable {}
extension AliIotConnectKit.SwiftyJSONError : Swift.Equatable {}
extension AliIotConnectKit.SwiftyJSONError : Swift.Hashable {}
extension AliIotConnectKit.SwiftyJSONError : Swift.RawRepresentable {}
extension AliIotConnectKit.`Type` : Swift.Equatable {}
extension AliIotConnectKit.`Type` : Swift.Hashable {}
extension AliIotConnectKit.`Type` : Swift.RawRepresentable {}
extension AliIotConnectKit.writingOptionsKeys : Swift.Equatable {}
extension AliIotConnectKit.writingOptionsKeys : Swift.Hashable {}
